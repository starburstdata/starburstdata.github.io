<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Starburst | Deserialization part 1</title>
    <meta name="viewport" content="width=device-width">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Starburst - Deserialization part 1">
    <meta property="og:description" content="Your hub to all knowledge about Starburst products.">
    <meta property="og:image" content="/assets/img/starburst-og-image.png">

    <link rel="stylesheet" href="/assets/fontawesome/css/all.css">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/css/mdb.min.css">
    <link rel="stylesheet" href="/assets/css/highlight.css">
    <link rel="stylesheet" href="/assets/css/fonts.css">
    <link rel="stylesheet" href="/assets/css/style.css">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114610397-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114610397-1');
</script>

<script>
  var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights@2.2.1";

  !function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
  (e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
  i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
  }(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Deserialization part 1 | Starburst</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Deserialization part 1" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is part 5 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Deserialization is the process of taking a JSON token stream and coalescing it into a Java object. Deserialization is the hardest part of this process. Serialization is straightforward because the JSON spec is very small and simple. Conversely, Java objects are complex and mapping from simple JSON objects into Java objects will require much more thought. Consequently, the deserialization portion of this series is broken into two parts: this introduction that introduces the design and a follow-up that shows the implementations for collection types and object types. The design For our library we implement something that loosely resembles a recursive descent parser. We define a deserializer for all Java types that we support. Each of these deserializers is responsible for accepting and coalescing each of the fields that it needs. When a deserializer encounters a type it doesn’t handle, it obtains a new deserializer for that type and calls this new deserializer passing in itself as the parent. When a deserializer is complete, it prepares its value and returns to the parent to continue processing until all tokens have been processed. This process is broken into two methods: public interface JsonDeserializer { interface TypedDeserializer { TypedDeserializer accept(JsonToken t); // accept token and return next deserializer to use Object value(); } TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type); } deserializerFor() is called to get a TypedDeserializer for a given type. JSON tokens from the stream are passed to that TypedDeserializer. Each time a token is passed to accept(), it returns the next deserializer to call when a new token is received. When all the tokens have been processed the final value can be received from the first deserializer created. Here is pseudocode for this: TypedDeserializer first; TypedDeserializer current; for-each-token -&gt; { if (first == null) { current = first = deserializer.deserializerFor(rootTypedDeserializer, type); } current = current.accept(token); } Object value = first.value(); Details Simple types like numbers, strings, etc. are straightforward to process. Collections and records are more complicated and are the subject of the follow-up deserialization article. We can create a general-purpose deserializer for these simple types. It can be used to map number tokens, string tokens, boolean tokens and null tokens to Java primitives and Strings. Let’s define a method that returns this deserializer: simpleTypedDeserializer &lt;T extends JsonToken&gt; TypedDeserializer simpleTypedDeserializer(TypedDeserializer parentTypedDeserializer, Class&lt;T&gt; tokenClass, Function&lt;T, Object&gt; valueProvider) { return new TypedDeserializer() { ... }; } We declare a generic method with a generic parameter that must extend JsonToken. The method receives the parent deserializer, the type of token to expect, and a mapper method that creates a Java object from the token. Here’s the complete definition of the deserializer: new TypedDeserializer() { private Object value; private boolean valueIsSet; @Override public TypedDeserializer accept(JsonToken jsonToken) { if (valueIsSet) { throw new RuntimeException(); } switch (jsonToken) { case NullToken __ -&gt; { value = null; valueIsSet = true; } case JsonToken __ when tokenClass.isAssignableFrom(jsonToken.getClass()) -&gt; { value = valueProvider.apply(tokenClass.cast(jsonToken)); valueIsSet = true; } default -&gt; throw new RuntimeException(); } return parentTypedDeserializer; } @Override public Object value() { if (!valueIsSet) { throw new RuntimeException(); } return value; } }; All the work is in the accept() method. This deserializer handles nulls in addition to values. Only one token is expected by this deserializer as simple values can be specified by one JSON token. It checks if the token received is the correct type and, if so, extracts the value and saves it. Otherwise, it is an error. Simple type mapping We must also implement the deserializerFor() method that maps a Java type to a deserializer. As usual, we use enhanced switch and pattern matching: TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type) { return switch (type) { case Class&lt;?&gt; clazz when clazz.equals(byte.class) || clazz.equals(Byte.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); case Class&lt;?&gt; clazz when clazz.equals(short.class) || clazz.equals(Short.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().shortValue()); case Class&lt;?&gt; clazz when clazz.equals(int.class) || clazz.equals(Integer.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().intValue()); case Class&lt;?&gt; clazz when clazz.equals(long.class) || clazz.equals(Long.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().longValue()); case Class&lt;?&gt; clazz when clazz.equals(float.class) || clazz.equals(Float.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().floatValue()); case Class&lt;?&gt; clazz when clazz.equals(double.class) || clazz.equals(Double.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().doubleValue()); case Class&lt;?&gt; clazz when clazz.equals(boolean.class) || clazz.equals(Boolean.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, BooleanToken.class, BooleanToken::value); case Class&lt;?&gt; clazz when Number.class.isAssignableFrom(clazz) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, NumberToken::value); case Class&lt;?&gt; clazz when clazz.equals(String.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, StringToken.class, StringToken::value); default -&gt; throw new RuntimeException(); }; } That’s a large wall of code but, hopefully, by now it’s easy to read. For example, the first case statement equates to this pseudocode: if (type instanceof Class&lt;?&gt;) { Class&lt;?&gt; clazz = (Class&lt;?&gt;) type; if (clazz.equals(byte.class) || clazz.equals(Byte.class)) { // the mapper calls byteValue() on the Number token return simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); } } Collector Java streams use the Collector mechanism to reduce stream elements into a single object. JsonDeserializerCollector.java is an implementation of a stream Collector. It defines an Accumulator class to manage the first and current serializers: class Accumulator { TypedDeserializer first; TypedDeserializer current; } The accumulator() method of the Collector then applies the token and manages the first and current deserializer: public BiConsumer&lt;Accumulator, JsonToken&gt; accumulator() { return (accumulator, jsonToken) -&gt; { if (accumulator.first == null) { accumulator.current = accumulator.first = deserializer.deserializerFor(rootTypedDeserializer, type); } accumulator.current = accumulator.current.accept(jsonToken); }; } Finally, the finisher() returns the value from the first deserializer and casts it to the desired type: public Function&lt;Accumulator, T&gt; finisher() { return accumulator -&gt; { if (accumulator.first == null) { throw new RuntimeException(); } return (T) accumulator.first.value(); }; } Next steps Now we can deserialize to tokens. In the follow-up article deserialization of complex types we continue developing deserializers for more complex types. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy." />
<meta property="og:description" content="This is part 5 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Deserialization is the process of taking a JSON token stream and coalescing it into a Java object. Deserialization is the hardest part of this process. Serialization is straightforward because the JSON spec is very small and simple. Conversely, Java objects are complex and mapping from simple JSON objects into Java objects will require much more thought. Consequently, the deserialization portion of this series is broken into two parts: this introduction that introduces the design and a follow-up that shows the implementations for collection types and object types. The design For our library we implement something that loosely resembles a recursive descent parser. We define a deserializer for all Java types that we support. Each of these deserializers is responsible for accepting and coalescing each of the fields that it needs. When a deserializer encounters a type it doesn’t handle, it obtains a new deserializer for that type and calls this new deserializer passing in itself as the parent. When a deserializer is complete, it prepares its value and returns to the parent to continue processing until all tokens have been processed. This process is broken into two methods: public interface JsonDeserializer { interface TypedDeserializer { TypedDeserializer accept(JsonToken t); // accept token and return next deserializer to use Object value(); } TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type); } deserializerFor() is called to get a TypedDeserializer for a given type. JSON tokens from the stream are passed to that TypedDeserializer. Each time a token is passed to accept(), it returns the next deserializer to call when a new token is received. When all the tokens have been processed the final value can be received from the first deserializer created. Here is pseudocode for this: TypedDeserializer first; TypedDeserializer current; for-each-token -&gt; { if (first == null) { current = first = deserializer.deserializerFor(rootTypedDeserializer, type); } current = current.accept(token); } Object value = first.value(); Details Simple types like numbers, strings, etc. are straightforward to process. Collections and records are more complicated and are the subject of the follow-up deserialization article. We can create a general-purpose deserializer for these simple types. It can be used to map number tokens, string tokens, boolean tokens and null tokens to Java primitives and Strings. Let’s define a method that returns this deserializer: simpleTypedDeserializer &lt;T extends JsonToken&gt; TypedDeserializer simpleTypedDeserializer(TypedDeserializer parentTypedDeserializer, Class&lt;T&gt; tokenClass, Function&lt;T, Object&gt; valueProvider) { return new TypedDeserializer() { ... }; } We declare a generic method with a generic parameter that must extend JsonToken. The method receives the parent deserializer, the type of token to expect, and a mapper method that creates a Java object from the token. Here’s the complete definition of the deserializer: new TypedDeserializer() { private Object value; private boolean valueIsSet; @Override public TypedDeserializer accept(JsonToken jsonToken) { if (valueIsSet) { throw new RuntimeException(); } switch (jsonToken) { case NullToken __ -&gt; { value = null; valueIsSet = true; } case JsonToken __ when tokenClass.isAssignableFrom(jsonToken.getClass()) -&gt; { value = valueProvider.apply(tokenClass.cast(jsonToken)); valueIsSet = true; } default -&gt; throw new RuntimeException(); } return parentTypedDeserializer; } @Override public Object value() { if (!valueIsSet) { throw new RuntimeException(); } return value; } }; All the work is in the accept() method. This deserializer handles nulls in addition to values. Only one token is expected by this deserializer as simple values can be specified by one JSON token. It checks if the token received is the correct type and, if so, extracts the value and saves it. Otherwise, it is an error. Simple type mapping We must also implement the deserializerFor() method that maps a Java type to a deserializer. As usual, we use enhanced switch and pattern matching: TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type) { return switch (type) { case Class&lt;?&gt; clazz when clazz.equals(byte.class) || clazz.equals(Byte.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); case Class&lt;?&gt; clazz when clazz.equals(short.class) || clazz.equals(Short.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().shortValue()); case Class&lt;?&gt; clazz when clazz.equals(int.class) || clazz.equals(Integer.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().intValue()); case Class&lt;?&gt; clazz when clazz.equals(long.class) || clazz.equals(Long.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().longValue()); case Class&lt;?&gt; clazz when clazz.equals(float.class) || clazz.equals(Float.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().floatValue()); case Class&lt;?&gt; clazz when clazz.equals(double.class) || clazz.equals(Double.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().doubleValue()); case Class&lt;?&gt; clazz when clazz.equals(boolean.class) || clazz.equals(Boolean.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, BooleanToken.class, BooleanToken::value); case Class&lt;?&gt; clazz when Number.class.isAssignableFrom(clazz) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, NumberToken::value); case Class&lt;?&gt; clazz when clazz.equals(String.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, StringToken.class, StringToken::value); default -&gt; throw new RuntimeException(); }; } That’s a large wall of code but, hopefully, by now it’s easy to read. For example, the first case statement equates to this pseudocode: if (type instanceof Class&lt;?&gt;) { Class&lt;?&gt; clazz = (Class&lt;?&gt;) type; if (clazz.equals(byte.class) || clazz.equals(Byte.class)) { // the mapper calls byteValue() on the Number token return simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); } } Collector Java streams use the Collector mechanism to reduce stream elements into a single object. JsonDeserializerCollector.java is an implementation of a stream Collector. It defines an Accumulator class to manage the first and current serializers: class Accumulator { TypedDeserializer first; TypedDeserializer current; } The accumulator() method of the Collector then applies the token and manages the first and current deserializer: public BiConsumer&lt;Accumulator, JsonToken&gt; accumulator() { return (accumulator, jsonToken) -&gt; { if (accumulator.first == null) { accumulator.current = accumulator.first = deserializer.deserializerFor(rootTypedDeserializer, type); } accumulator.current = accumulator.current.accept(jsonToken); }; } Finally, the finisher() returns the value from the first deserializer and casts it to the desired type: public Function&lt;Accumulator, T&gt; finisher() { return accumulator -&gt; { if (accumulator.first == null) { throw new RuntimeException(); } return (T) accumulator.first.value(); }; } Next steps Now we can deserialize to tokens. In the follow-up article deserialization of complex types we continue developing deserializers for more complex types. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy." />
<link rel="canonical" href="https://docs.starburst.io/blog_bej/2022-09-20-bej5-deserialization.html" />
<meta property="og:url" content="https://docs.starburst.io/blog_bej/2022-09-20-bej5-deserialization.html" />
<meta property="og:site_name" content="Starburst" />
<meta property="og:image" content="https://docs.starburst.io/assets/img/logo/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-20T00:00:00-05:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://docs.starburst.io/assets/img/logo/java.png" />
<meta property="twitter:title" content="Deserialization part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-20T00:00:00-05:00","datePublished":"2022-09-20T00:00:00-05:00","description":"This is part 5 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Deserialization is the process of taking a JSON token stream and coalescing it into a Java object. Deserialization is the hardest part of this process. Serialization is straightforward because the JSON spec is very small and simple. Conversely, Java objects are complex and mapping from simple JSON objects into Java objects will require much more thought. Consequently, the deserialization portion of this series is broken into two parts: this introduction that introduces the design and a follow-up that shows the implementations for collection types and object types. The design For our library we implement something that loosely resembles a recursive descent parser. We define a deserializer for all Java types that we support. Each of these deserializers is responsible for accepting and coalescing each of the fields that it needs. When a deserializer encounters a type it doesn’t handle, it obtains a new deserializer for that type and calls this new deserializer passing in itself as the parent. When a deserializer is complete, it prepares its value and returns to the parent to continue processing until all tokens have been processed. This process is broken into two methods: public interface JsonDeserializer { interface TypedDeserializer { TypedDeserializer accept(JsonToken t); // accept token and return next deserializer to use Object value(); } TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type); } deserializerFor() is called to get a TypedDeserializer for a given type. JSON tokens from the stream are passed to that TypedDeserializer. Each time a token is passed to accept(), it returns the next deserializer to call when a new token is received. When all the tokens have been processed the final value can be received from the first deserializer created. Here is pseudocode for this: TypedDeserializer first; TypedDeserializer current; for-each-token -&gt; { if (first == null) { current = first = deserializer.deserializerFor(rootTypedDeserializer, type); } current = current.accept(token); } Object value = first.value(); Details Simple types like numbers, strings, etc. are straightforward to process. Collections and records are more complicated and are the subject of the follow-up deserialization article. We can create a general-purpose deserializer for these simple types. It can be used to map number tokens, string tokens, boolean tokens and null tokens to Java primitives and Strings. Let’s define a method that returns this deserializer: simpleTypedDeserializer &lt;T extends JsonToken&gt; TypedDeserializer simpleTypedDeserializer(TypedDeserializer parentTypedDeserializer, Class&lt;T&gt; tokenClass, Function&lt;T, Object&gt; valueProvider) { return new TypedDeserializer() { ... }; } We declare a generic method with a generic parameter that must extend JsonToken. The method receives the parent deserializer, the type of token to expect, and a mapper method that creates a Java object from the token. Here’s the complete definition of the deserializer: new TypedDeserializer() { private Object value; private boolean valueIsSet; @Override public TypedDeserializer accept(JsonToken jsonToken) { if (valueIsSet) { throw new RuntimeException(); } switch (jsonToken) { case NullToken __ -&gt; { value = null; valueIsSet = true; } case JsonToken __ when tokenClass.isAssignableFrom(jsonToken.getClass()) -&gt; { value = valueProvider.apply(tokenClass.cast(jsonToken)); valueIsSet = true; } default -&gt; throw new RuntimeException(); } return parentTypedDeserializer; } @Override public Object value() { if (!valueIsSet) { throw new RuntimeException(); } return value; } }; All the work is in the accept() method. This deserializer handles nulls in addition to values. Only one token is expected by this deserializer as simple values can be specified by one JSON token. It checks if the token received is the correct type and, if so, extracts the value and saves it. Otherwise, it is an error. Simple type mapping We must also implement the deserializerFor() method that maps a Java type to a deserializer. As usual, we use enhanced switch and pattern matching: TypedDeserializer deserializerFor(TypedDeserializer parentTypedDeserializer, Type type) { return switch (type) { case Class&lt;?&gt; clazz when clazz.equals(byte.class) || clazz.equals(Byte.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); case Class&lt;?&gt; clazz when clazz.equals(short.class) || clazz.equals(Short.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().shortValue()); case Class&lt;?&gt; clazz when clazz.equals(int.class) || clazz.equals(Integer.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().intValue()); case Class&lt;?&gt; clazz when clazz.equals(long.class) || clazz.equals(Long.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().longValue()); case Class&lt;?&gt; clazz when clazz.equals(float.class) || clazz.equals(Float.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().floatValue()); case Class&lt;?&gt; clazz when clazz.equals(double.class) || clazz.equals(Double.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().doubleValue()); case Class&lt;?&gt; clazz when clazz.equals(boolean.class) || clazz.equals(Boolean.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, BooleanToken.class, BooleanToken::value); case Class&lt;?&gt; clazz when Number.class.isAssignableFrom(clazz) -&gt; simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, NumberToken::value); case Class&lt;?&gt; clazz when clazz.equals(String.class) -&gt; simpleTypedDeserializer(parentTypedDeserializer, StringToken.class, StringToken::value); default -&gt; throw new RuntimeException(); }; } That’s a large wall of code but, hopefully, by now it’s easy to read. For example, the first case statement equates to this pseudocode: if (type instanceof Class&lt;?&gt;) { Class&lt;?&gt; clazz = (Class&lt;?&gt;) type; if (clazz.equals(byte.class) || clazz.equals(Byte.class)) { // the mapper calls byteValue() on the Number token return simpleTypedDeserializer(parentTypedDeserializer, NumberToken.class, numberToken -&gt; numberToken.value().byteValue()); } } Collector Java streams use the Collector mechanism to reduce stream elements into a single object. JsonDeserializerCollector.java is an implementation of a stream Collector. It defines an Accumulator class to manage the first and current serializers: class Accumulator { TypedDeserializer first; TypedDeserializer current; } The accumulator() method of the Collector then applies the token and manages the first and current deserializer: public BiConsumer&lt;Accumulator, JsonToken&gt; accumulator() { return (accumulator, jsonToken) -&gt; { if (accumulator.first == null) { accumulator.current = accumulator.first = deserializer.deserializerFor(rootTypedDeserializer, type); } accumulator.current = accumulator.current.accept(jsonToken); }; } Finally, the finisher() returns the value from the first deserializer and casts it to the desired type: public Function&lt;Accumulator, T&gt; finisher() { return accumulator -&gt; { if (accumulator.first == null) { throw new RuntimeException(); } return (T) accumulator.first.value(); }; } Next steps Now we can deserialize to tokens. In the follow-up article deserialization of complex types we continue developing deserializers for more complex types. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy.","headline":"Deserialization part 1","image":"https://docs.starburst.io/assets/img/logo/java.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://docs.starburst.io/blog_bej/2022-09-20-bej5-deserialization.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://docs.starburst.io/assets/img/logo/starburst-reverse.png"}},"url":"https://docs.starburst.io/blog_bej/2022-09-20-bej5-deserialization.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>


<header class="main-header navbar-expand-sm">
  <div class="navbar fixed-top navbar-dark">
    <div class="navbar-left-container">
      <a class="navbar-brand" href="https://www.starburst.io/">
        <img src="/assets/img/logo/starburst_KO-T.png" height="32" alt="Starburst">
      </a>
      <span class="navbar-divider"></span>
      <a href="/" class="header-text">Documentation</a>
    </div>
    
    <div class="nav-item dropdown" id="site-search">
  <div id="dropdownSearchDisplay" aria-labelledby="dropdownSearch">
    <div id="algolia-search">
      <div id="searchbox"></div>
      <div id="refinement-list">
        <h6>Filter:</h6>
      </div>
      <div id="hits"></div>
      <div id="stats"></div>
    </div>
  </div>
</div>

    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
    <nav class="primary-nav">
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-layout navbar-nav mr-auto">
          <li class="nav-item dropdown">
            <a id="get-started"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/get-started/index.html">Get started</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/get-started/concepts.html">Concepts</a>
              <a class="dropdown-item" href="/get-started/architecture.html">Architecture</a>
              <a class="dropdown-item" href="/get-started/data-sources-catalogs.html">Data sources and catalogs</a>
              <a class="dropdown-item" href="/get-started/security.html">Security</a>
              <a class="dropdown-item" href="/get-started/choose-your-starburst-product.html">Choose your Starburst product</a>
              <a class="dropdown-item" href="/data-consumer/index.html">Data consumer</a>
              <a class="dropdown-item" href="/data-engineer/index.html">Data engineer</a>
              <a class="dropdown-item" href="/platform-administrator/index.html">Platform administrator</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-galaxy"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Starburst Galaxy" data-is-click="false"
              href="/starburst-galaxy/index.html">Starburst Galaxy</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-galaxy/query/index.html">Query</a>
              <a class="dropdown-item" href="/starburst-galaxy/catalogs/index.html">Catalogs</a>
              <a class="dropdown-item" href="/starburst-galaxy/catalog-explorer/index.html">Catalog explorer</a>
              <a class="dropdown-item" href="/starburst-galaxy/clusters/index.html">Clusters</a>
              <a class="dropdown-item" href="/starburst-galaxy/sql/index.html">SQL</a>
              <a class="dropdown-item" href="/starburst-galaxy/admin/index.html">Admin</a>
              <a class="dropdown-item" href="/starburst-galaxy/access-control/index.html">Access control</a>
              <a class="dropdown-item" href="/starburst-galaxy/cloud-settings/index.html">Cloud settings</a>
              <a class="dropdown-item" href="/starburst-galaxy/security/index.html">Security</a>
              <a class="dropdown-item" href="/starburst-galaxy/sso/index.html">Single sign-on</a>
              <a class="dropdown-item" href="/starburst-galaxy/api.html">API</a>
              <a class="dropdown-item" href="/starburst-galaxy/tutorials/index.html">Tutorials</a>
              <a class="dropdown-item" href="/starburst-galaxy/troubleshooting/index.html">Troubleshooting</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-enterprise"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/starburst-enterprise/index.html">Starburst Enterprise</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-enterprise/try/index.html">Try Starburst Enterprise</a>
              <a class="dropdown-item" href="/starburst-enterprise/web-ui/index.html">Web UI</a>
              <a class="dropdown-item" href="/starburst-enterprise/sql.html">SQL</a>
              <a class="dropdown-item" href="/starburst-enterprise/admin-topics/index.html">Administration</a>
              <a class="dropdown-item" href="/starburst-enterprise/k8s/index.html">Kubernetes deployments</a>
              <a class="dropdown-item" href="/starburst-enterprise/starburst-admin/index.html">Starburst Admin</a>
              <a class="dropdown-item" href="/latest/index.html">Reference documentation</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="ecosystems"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/ecosystems/index.html">Ecosystems</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/ecosystems/amazon/index.html">Amazon AWS</a>
              <a class="dropdown-item" href="/ecosystems/google/index.html">Google Cloud</a>
              <a class="dropdown-item" href="/ecosystems/microsoft/index.html">Microsoft Azure</a>
              <a class="dropdown-item" href="/ecosystems/redhat/index.html">Red Hat OpenShift</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="resources"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="resources" data-is-click="false"
              href="/resources.html">Resources</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/support.html">Support</a>
              <a class="dropdown-item" href="/security/index.html">Security</a>
              <a class="dropdown-item" href="/blog/index.html">Developer blog</a>
              <a class="dropdown-item" href="/videos/index.html">Video library</a>
              <a class="dropdown-item" href="/glossary.html">Glossary</a>
              <a class="dropdown-item" href="https://www.trinoforum.org/">Trino forum</a>
            </div>
          </li>
        </ul>
      </div>
    </nav>
</header>

    <div class="landing-page">
        <div class="sep-hero">
  <div class="container sep-parent">
    <div class="row">
      <div class="col-md-12">
        <h1><a href="/blog/">Starburst developer blog</a></h1>
        <p class="lead">The latest news from our users, engineers, writers, and
        product folks for all our peers and friends out there.</p>
        <p>Want even more updates and information? Go to the
          <a href="https://blog.starburst.io/">Starburst company blog</a>.</p>
      </div>
    </div>
  </div>
</div>

  


<div class="content container-fluid post-container clearfix spacer-30">

  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="container">
      <div class="row">

        <div class="col-xl-3">
          <h3>Contents</h3>
          <ul class="list-group">
            
              
                <a class="list-group-item" href="/blog/2022-09-20-bej0-introduction.html">Bleeding edge Java</a>
              
            
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej1-design.html">Designing a JSON model</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej2-serialization.html">Serialization</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej3-printing.html">Printing</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej4-parsing.html">Parsing</a>
              
            
              
                <li class="list-group-item active">Deserialization part 1</li>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej6-deserialization.html">Deserialization part 2</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej7-conclusion.html">Conclusion</a>
              
            
          </ul>
        </div>

        <div class="col-xl-9">
          <header class="post-header">
            <h1 class="post-title p-name" itemprop="name headline">
              Deserialization part 1</h1>
            <p class="post-meta">
              <time class="dt-published" abbrtime="2022-09-20T00:00:00-05:00" itemprop="datePublished">
                Sep 20, 2022
              </time> |

     Jordan Zimmerman
     
     
     <a href="https://github.com/randgalt" target="_blank"><i class="fab fa-github"></i></a>
     
     
</p>
          </header>

          <div class="content width clearfix" itemprop="articleBody"><img src="../assets/img/logo/java.png" style="float: right;"><p><em>This is part 5 of the Bleeding edge Java series. <a href="/blog/2022-09-20-bej0-introduction.html">Start at the
introduction</a> if you haven’t
already.</em></p>

<p>Deserialization is the process of taking a JSON token stream and coalescing it
into a Java object. Deserialization is the hardest part of this process.
Serialization is straightforward because the JSON spec is very small and simple.
Conversely, Java objects are complex and mapping from simple JSON objects into
Java objects will require much more thought. Consequently, the deserialization
portion of this series is broken into two parts: this introduction that
introduces the design and a follow-up that shows the implementations for
collection types and object types.</p>

<h2 id="the-design">The design</h2>

<p>For our library we implement something that loosely resembles a <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank">recursive
descent parser</a>. 
We define a deserializer for all Java types that we support.
Each of these deserializers is responsible for accepting and coalescing each of
the fields that it needs. When a deserializer encounters a type it doesn’t
handle, it obtains a new deserializer for that type and calls this new
deserializer passing in itself as the parent. When a deserializer is complete,
it prepares its value and returns to the parent to continue processing until all
tokens have been processed. This process is broken into two methods:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JsonDeserializer</span>
<span class="o">{</span>
    <span class="kd">interface</span> <span class="nc">TypedDeserializer</span>
    <span class="o">{</span>
        <span class="nc">TypedDeserializer</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">JsonToken</span> <span class="n">t</span><span class="o">);</span>  <span class="c1">// accept token and return next deserializer to use</span>

        <span class="nc">Object</span> <span class="nf">value</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nc">TypedDeserializer</span> <span class="nf">deserializerFor</span><span class="o">(</span><span class="nc">TypedDeserializer</span> <span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">Type</span> <span class="n">type</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">deserializerFor()</code> is called to get a <code class="language-plaintext highlighter-rouge">TypedDeserializer</code> for a given type.
JSON tokens from the stream are passed to that <code class="language-plaintext highlighter-rouge">TypedDeserializer</code>. Each time a
token is passed to <code class="language-plaintext highlighter-rouge">accept()</code>, it returns the next deserializer to call when a
new token is received. When all the tokens have been processed the final value
can be received from the first deserializer created. Here is pseudocode for
this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypedDeserializer</span> <span class="n">first</span><span class="o">;</span>
<span class="nc">TypedDeserializer</span> <span class="n">current</span><span class="o">;</span>
<span class="k">for</span><span class="o">-</span><span class="n">each</span><span class="o">-</span><span class="n">token</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">first</span> <span class="o">=</span> <span class="n">deserializer</span><span class="o">.</span><span class="na">deserializerFor</span><span class="o">(</span><span class="n">rootTypedDeserializer</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">token</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="details">Details</h2>

<p>Simple types like numbers, strings, etc. are straightforward to process.
Collections and records are more complicated and are the subject of the
follow-up deserialization article. We can create a general-purpose deserializer
for these simple types. It can be used to map number tokens, string tokens,
boolean tokens and null tokens to Java primitives and Strings. Let’s define a
method that returns this deserializer:</p>

<h3 id="simpletypeddeserializer">simpleTypedDeserializer</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="nc">TypedDeserializer</span> <span class="nf">simpleTypedDeserializer</span><span class="o">(</span><span class="nc">TypedDeserializer</span> <span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">tokenClass</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">valueProvider</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">TypedDeserializer</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We declare a generic method with a generic parameter that must extend
<code class="language-plaintext highlighter-rouge">JsonToken</code>. The method receives the parent deserializer, the type of token to
expect, and a mapper method that creates a Java object from the token.</p>

<p>Here’s the complete definition of the deserializer:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nc">TypedDeserializer</span><span class="o">()</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">valueIsSet</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">TypedDeserializer</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">JsonToken</span> <span class="n">jsonToken</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">valueIsSet</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">jsonToken</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">NullToken</span> <span class="n">__</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">valueIsSet</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">case</span> <span class="nc">JsonToken</span> <span class="n">__</span> <span class="n">when</span> <span class="n">tokenClass</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">jsonToken</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">valueProvider</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">tokenClass</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">jsonToken</span><span class="o">));</span>
                <span class="n">valueIsSet</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">default</span> <span class="o">-&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">parentTypedDeserializer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">value</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">valueIsSet</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">};</span>

</code></pre></div></div>

<p>All the work is in the <code class="language-plaintext highlighter-rouge">accept()</code> method. This deserializer handles nulls in
addition to values. Only one token is expected by this deserializer as simple
values can be specified by one JSON token. It checks if the token received is
the correct type and, if so, extracts the value and saves it. Otherwise, it is
an error.</p>

<h3 id="simple-type-mapping">Simple type mapping</h3>

<p>We must also implement the <code class="language-plaintext highlighter-rouge">deserializerFor()</code> method that maps a Java type to a
deserializer. As usual, we use enhanced switch and pattern matching:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypedDeserializer</span> <span class="nf">deserializerFor</span><span class="o">(</span><span class="nc">TypedDeserializer</span> <span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">Type</span> <span class="n">type</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span> <span class="o">(</span><span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">byte</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Byte</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">byteValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">short</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Short</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">shortValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">intValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">long</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">longValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">float</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Float</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">floatValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">double</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">doubleValue</span><span class="o">());</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">boolean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Boolean</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">BooleanToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nl">BooleanToken:</span><span class="o">:</span><span class="n">value</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="nc">Number</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="n">clazz</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nl">NumberToken:</span><span class="o">:</span><span class="n">value</span><span class="o">);</span>
        <span class="k">case</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="n">when</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">-&gt;</span> 
                <span class="n">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">StringToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nl">StringToken:</span><span class="o">:</span><span class="n">value</span><span class="o">);</span>
        <span class="k">default</span> <span class="o">-&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s a large wall of code but, hopefully, by now it’s easy to read. For
example, the first case statement equates to this pseudocode:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="k">instanceof</span> <span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="o">{</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">type</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="kt">byte</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">||</span> <span class="n">clazz</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Byte</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// the mapper calls byteValue() on the Number token</span>
        <span class="k">return</span> <span class="nf">simpleTypedDeserializer</span><span class="o">(</span><span class="n">parentTypedDeserializer</span><span class="o">,</span> <span class="nc">NumberToken</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">numberToken</span> <span class="o">-&gt;</span> <span class="n">numberToken</span><span class="o">.</span><span class="na">value</span><span class="o">().</span><span class="na">byteValue</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="collector">Collector</h2>

<p>Java streams use the Collector mechanism to reduce stream elements into a single
object.
<a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonDeserializerCollector.java" target="_blank">JsonDeserializerCollector.java</a>
is an implementation of a stream Collector.</p>

<p>It defines an Accumulator class to manage the first and current serializers:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Accumulator</span>
<span class="o">{</span>
    <span class="nc">TypedDeserializer</span> <span class="n">first</span><span class="o">;</span>
    <span class="nc">TypedDeserializer</span> <span class="n">current</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">accumulator()</code> method of the Collector then applies the token and manages
the first and current deserializer:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="nc">Accumulator</span><span class="o">,</span> <span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="nf">accumulator</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">accumulator</span><span class="o">,</span> <span class="n">jsonToken</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">accumulator</span><span class="o">.</span><span class="na">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">accumulator</span><span class="o">.</span><span class="na">current</span> <span class="o">=</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">deserializer</span><span class="o">.</span><span class="na">deserializerFor</span><span class="o">(</span><span class="n">rootTypedDeserializer</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">accumulator</span><span class="o">.</span><span class="na">current</span> <span class="o">=</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">current</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">jsonToken</span><span class="o">);</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Finally, the <code class="language-plaintext highlighter-rouge">finisher()</code> returns the value from the first deserializer and
casts it to the desired type:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Accumulator</span><span class="o">,</span> <span class="no">T</span><span class="o">&gt;</span> <span class="nf">finisher</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">accumulator</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">accumulator</span><span class="o">.</span><span class="na">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">first</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
    <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="next-steps">Next steps</h2>

<p>Now we can deserialize to tokens. In the  follow-up article <a href="/blog_bej/2022-09-20-bej6-deserialization.html">deserialization of complex types</a> 
we continue developing deserializers for
more complex types.</p>

<h2 id="were-hiring">We’re hiring</h2>

<p>Want to be able to use the latest features of Java? <a href="https://www.starburst.io/careers/" target="_blank">We’re
hiring!</a></p>

<hr />

<p>Jordan Zimmerman is a Senior Software Engineer working on <a href="https://www.starburst.io/platform/starburst-galaxy/" target="_blank">Starburst
Galaxy</a>.</p>

          </div>
        </div>
      </div>
    </div>

    <a class="u-url" href="/blog_bej/2022-09-20-bej5-deserialization.html" hidden></a>
  </article>

</div>



    </div>


<div style="margin-bottom: 50px"></div><footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-6">
        <p style="font-weight:900">Resources</b></p>
        <ul>
          <li class="footer-item"><a href="/videos/index.html">Video library</a></li>
          <li class="footer-item"><a href="/glossary.html">Glossary</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/info/oreilly-trino-guide/" target="_blank">Free O'Reilly book - Trino: The Definitive Guide</a></li>
          <li class="footer-item"><a href="https://trino.io/broadcast/" target="_blank">Trino Community Broadcast</a></li>
          <li class="footer-item"><a href="https://trinoforum.org" target="_blank">Trino Forum</a></li>
          <li class="footer-item"><a href="https://blog.starburstdata.com/" target="_blank">Starburst blog</a></li>
        </ul>
      </div>
      <div class="col-md-3">
        <p style="font-weight:900">Contact and more</p>
        <ul>
          <li class="footer-item"><a href="https://www.starburst.io" target="_blank">Starburst</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/#download" target="_blank">Start a trial</a></li>
          <li class="footer-item"><a href="/support.html" target="_blank">Get support</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/contact/" target="_blank">Contact us</a></li>
        </ul>
      </div>
      <div class="col-md-3" style="text-align:right;">
        <a href="https://www.starburst.io/" target="_blank"><img src="/assets/img/logo/starburst-reverse.png" height="60" alt=" Starburst" style="margin-bottom:20px;"></a>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#copyright">Copyright © 2017-2022<br> Starburst Data</a>
        </li>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#trademarks">Trademark information</a>
        </li>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 center spacer-30">
          <a href="https://twitter.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-twitter"></i></a>
          <a href="https://linkedin.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-linkedin"></i></a>
          <a href="https://www.youtube.com/channel/UCXjkuWSO9CV_cSI3Mvo4a4w" target="_blank" class="footer-icon"><i class="fab fa-youtube"></i></a>
          <a href="https://github.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-github"></i></a>
      </div>
    </div>
  </div>
</footer>
  <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/popper.min.js"></script>
  <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/assets/js/mdb.min.js"></script>
  <script type="text/javascript" src="/assets/js/custom.js"></script>
  <script type="text/javascript" src="/assets/js/algolia.js"></script>
  <script type="text/javascript" src="/assets/js/search-box.js"></script>
  <script type="text/javascript" src="/assets/js/search-results.js"></script>
</body>
</html>
