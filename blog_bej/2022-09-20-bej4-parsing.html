<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Starburst | Parsing</title>
    <meta name="viewport" content="width=device-width">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Starburst - Parsing">
    <meta property="og:description" content="Your hub to all knowledge about Starburst products.">
    <meta property="og:image" content="/assets/img/starburst-og-image.png">

    <link rel="stylesheet" href="/assets/fontawesome/css/all.css">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/css/mdb.min.css">
    <link rel="stylesheet" href="/assets/css/highlight.css">
    <link rel="stylesheet" href="/assets/css/fonts.css">
    <link rel="stylesheet" href="/assets/css/style.css">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114610397-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114610397-1');
</script>

<script>
  var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights@2.2.1";

  !function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
  (e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
  i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
  }(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Parsing | Starburst</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Parsing" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is part 4 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Parsing is the process of interpreting free form JSON text and converting it into a stream of JSON tokens. The JSON Spec defines the manner in which parsing should be done: what constitutes whitespace, escape sequences in strings, etc. In short, take a stream of characters and interpret those characters as a stream of JSON tokens. We can define a Java interface for this: public interface JsonParser { Stream&lt;JsonToken&gt; parse(IntStream stream); // Note: Java Strings can be streamed via the chars() method } Instead of a normal Java Stream we need to use an IntStream as we’re dealing with primitive values: characters. Java does not have a CharStream so IntStream will suffice. There are a number of wrinkles we’ll have to deal with when interpreting characters: We sometimes need to look ahead before we know what token type is implied (for literals, strings, numbers) Our library introduces an object name token. This means that when we parse a string we need to wait for the next token. If it’s a : we have to convert the string into an object name. Number tokens can possibly end with a parseable character: , [ {. When this happens we need to reprocess that character. Here is the general flow for parsing JSON text: The code Java streams process an element at a time and don’t allow arbitrary forward/backward access. This limitation would make writing a parser very difficult. Fortunately, a stream can be converted into an Iterator which allows the parser to continue accessing characters in the stream as needed. The stream method iterator() is used to access this iterator whose type has the unfortunately complex name PrimitiveIterator.OfInt. Another issue with Java streams is that it’s not simple to generate a stream with an unknown length. The management of stream ending occurs in the JDK and there aren’t exposed methods to control this. However, you can easily convert an Iterator to a stream. Our parser can create an Iterator internally which can continue to return tokens until parsing is complete and then its hasNext() method can return false. Putting this together we need these variables: PrimitiveIterator.OfInt iterator - the iterator of the character stream being processed LinkedList&lt;JsonToken&gt; tokens - the list of tokens that should be returned from our iterator. We need a list because we will sometimes have more than one token to return. int pushedBack - this is the possibly pushed back character from number parsing or -1 Our parser implementation looks like this: Stream&lt;JsonToken&gt; parse(IntStream stream) { Iterator&lt;JsonToken&gt; tokenIterator = new Iterator&lt;&gt;() { ... }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize(tokenIterator, 0), false); // standard method of converting an Iterator to a stream } The first step in our internal iterator is to prepare our state variables: private final StringBuilder builder = new StringBuilder(); // contains currently being parsed string, number, etc. private final PrimitiveIterator.OfInt iterator = stream.iterator(); // stream of characters being processed as an Iterator private final LinkedList&lt;JsonToken&gt; tokens = new LinkedList&lt;&gt;(); // list of tokens that need to be returned private int pushedBack = -1; // possibly pushed back character from number parsing or -1 The hasNext() implementation for our iterator is straightforward: public boolean hasNext() { return !tokens.isEmpty(); } The majority of the implementation in our iterator will be in the method advanceToNextToken() which advances to the next token in the stream updating the state variables in the process. Before we show this let’s show the implementation for the next() method of our iterator: public JsonToken next() { if (tokens.isEmpty()) { throw new RuntimeException(); } JsonToken result = tokens.removeFirst(); // remove the first token and save it advanceToNextToken(); // advance return result; // return the token } Now we implement advanceToNextToken(). First let’s advance past any whitespace unless there’s a pushed-back character: if (pushedBack &lt; 0) { pushedBack = advanceWhitespace(iterator); // note: advanceWhitespace() can generate a new pushed-back character } Next we loop over characters from the character stream until we have a token. String possibleObjectName = null; // set when a string is processed JsonToken nextToken = null; while ((nextToken == null) &amp;&amp; ((pushedBack &gt;= 0) || iterator.hasNext())) { char c = (char) (((pushedBack &gt;= 0) ? pushedBack : iterator.nextInt()) &amp; 0xffff); pushedBack = -1; ... process character ... } if (possibleObjectName != null) { // wasn&#39;t an object name - we now have to emit this string token first tokens.add(new StringToken(possibleObjectName)); } if (nextToken != null) { tokens.add(nextToken); } We only need to process each character - again using enhanced switch: nextToken = switch (c) { case &#39;{&#39; -&gt; new BeginObjectToken(); case &#39;}&#39; -&gt; new EndObjectToken(); case &#39;[&#39; -&gt; new BeginArrayToken(); case &#39;]&#39; -&gt; new EndArrayToken(); case &#39;,&#39; -&gt; new ValueSeparatorToken(); case &#39;&quot;&#39; -&gt; { if (possibleObjectName != null) { throw new RuntimeException(); // can&#39;t have more than one string } possibleObjectName = StringUtils.parseString(builder, iterator); // it may be an object name so we have to keep parsing yield null; } case &#39;t&#39; -&gt; parseLiteral(iterator, &quot;rue&quot;, new BooleanToken(true)); // see the Java source for details on parseLiteral() case &#39;f&#39; -&gt; parseLiteral(iterator, &quot;alse&quot;, new BooleanToken(false)); case &#39;n&#39; -&gt; parseLiteral(iterator, &quot;ull&quot;, new NullToken()); case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;+&#39;, &#39;.&#39;, &#39;e&#39;, &#39;E&#39; -&gt; new NumberToken(StringUtils.parseNumber(builder, c, iterator, i -&gt; pushedBack = i)); // see Java source for details on StringUtils.parseNumber case &#39;:&#39; -&gt; { if (possibleObjectName == null) { throw new RuntimeException(); // illegal state - &#39;:&#39; without a preceeding string } ObjectNameToken objectNameToken = new ObjectNameToken(possibleObjectName); possibleObjectName = null; yield objectNameToken; } default -&gt; { if (StringUtils.isWhitespace(c)) { yield null; // ignore whitespace between tokens } throw new RuntimeException(); // unexpected character } }; See JsonParser.java for the full implementation. Test it out for yourself! In the previous articles we developed a serializer and a printer. Now we can reverse the process and take JSON text to produce a stream of JSON tokens. Let’s put this together in jshell. The example use these files: TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java From a terminal with Java 19 installed, run the following (note you’ll need the wget utility): wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/TypeToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonSerializer.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/StringUtils.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonPrinter.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java jshell --enable-preview TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java Inside jshell let’s serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens: var serializer = JsonSerializer.instance(); var printer = JsonPrinter.instance(); var parser = JsonParser.instance(); record Person(String name, int age) {} var person = new Person(&quot;someone&quot;, 28); serializer.serialize(person) // serialize to stream of JsonToken .map(printer::print) // map each JsonToken to a String (as a CharSequence) .map(CharSequence::chars) // map each CharSequence to an IntStream .flatMap(parser::parse) // pass each IntStream to the parser and flatten the resulting stream of tokens .forEach(System.out::println); // print each token to standard out Summary We can now serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens. Next up is deserialization. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy." />
<meta property="og:description" content="This is part 4 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Parsing is the process of interpreting free form JSON text and converting it into a stream of JSON tokens. The JSON Spec defines the manner in which parsing should be done: what constitutes whitespace, escape sequences in strings, etc. In short, take a stream of characters and interpret those characters as a stream of JSON tokens. We can define a Java interface for this: public interface JsonParser { Stream&lt;JsonToken&gt; parse(IntStream stream); // Note: Java Strings can be streamed via the chars() method } Instead of a normal Java Stream we need to use an IntStream as we’re dealing with primitive values: characters. Java does not have a CharStream so IntStream will suffice. There are a number of wrinkles we’ll have to deal with when interpreting characters: We sometimes need to look ahead before we know what token type is implied (for literals, strings, numbers) Our library introduces an object name token. This means that when we parse a string we need to wait for the next token. If it’s a : we have to convert the string into an object name. Number tokens can possibly end with a parseable character: , [ {. When this happens we need to reprocess that character. Here is the general flow for parsing JSON text: The code Java streams process an element at a time and don’t allow arbitrary forward/backward access. This limitation would make writing a parser very difficult. Fortunately, a stream can be converted into an Iterator which allows the parser to continue accessing characters in the stream as needed. The stream method iterator() is used to access this iterator whose type has the unfortunately complex name PrimitiveIterator.OfInt. Another issue with Java streams is that it’s not simple to generate a stream with an unknown length. The management of stream ending occurs in the JDK and there aren’t exposed methods to control this. However, you can easily convert an Iterator to a stream. Our parser can create an Iterator internally which can continue to return tokens until parsing is complete and then its hasNext() method can return false. Putting this together we need these variables: PrimitiveIterator.OfInt iterator - the iterator of the character stream being processed LinkedList&lt;JsonToken&gt; tokens - the list of tokens that should be returned from our iterator. We need a list because we will sometimes have more than one token to return. int pushedBack - this is the possibly pushed back character from number parsing or -1 Our parser implementation looks like this: Stream&lt;JsonToken&gt; parse(IntStream stream) { Iterator&lt;JsonToken&gt; tokenIterator = new Iterator&lt;&gt;() { ... }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize(tokenIterator, 0), false); // standard method of converting an Iterator to a stream } The first step in our internal iterator is to prepare our state variables: private final StringBuilder builder = new StringBuilder(); // contains currently being parsed string, number, etc. private final PrimitiveIterator.OfInt iterator = stream.iterator(); // stream of characters being processed as an Iterator private final LinkedList&lt;JsonToken&gt; tokens = new LinkedList&lt;&gt;(); // list of tokens that need to be returned private int pushedBack = -1; // possibly pushed back character from number parsing or -1 The hasNext() implementation for our iterator is straightforward: public boolean hasNext() { return !tokens.isEmpty(); } The majority of the implementation in our iterator will be in the method advanceToNextToken() which advances to the next token in the stream updating the state variables in the process. Before we show this let’s show the implementation for the next() method of our iterator: public JsonToken next() { if (tokens.isEmpty()) { throw new RuntimeException(); } JsonToken result = tokens.removeFirst(); // remove the first token and save it advanceToNextToken(); // advance return result; // return the token } Now we implement advanceToNextToken(). First let’s advance past any whitespace unless there’s a pushed-back character: if (pushedBack &lt; 0) { pushedBack = advanceWhitespace(iterator); // note: advanceWhitespace() can generate a new pushed-back character } Next we loop over characters from the character stream until we have a token. String possibleObjectName = null; // set when a string is processed JsonToken nextToken = null; while ((nextToken == null) &amp;&amp; ((pushedBack &gt;= 0) || iterator.hasNext())) { char c = (char) (((pushedBack &gt;= 0) ? pushedBack : iterator.nextInt()) &amp; 0xffff); pushedBack = -1; ... process character ... } if (possibleObjectName != null) { // wasn&#39;t an object name - we now have to emit this string token first tokens.add(new StringToken(possibleObjectName)); } if (nextToken != null) { tokens.add(nextToken); } We only need to process each character - again using enhanced switch: nextToken = switch (c) { case &#39;{&#39; -&gt; new BeginObjectToken(); case &#39;}&#39; -&gt; new EndObjectToken(); case &#39;[&#39; -&gt; new BeginArrayToken(); case &#39;]&#39; -&gt; new EndArrayToken(); case &#39;,&#39; -&gt; new ValueSeparatorToken(); case &#39;&quot;&#39; -&gt; { if (possibleObjectName != null) { throw new RuntimeException(); // can&#39;t have more than one string } possibleObjectName = StringUtils.parseString(builder, iterator); // it may be an object name so we have to keep parsing yield null; } case &#39;t&#39; -&gt; parseLiteral(iterator, &quot;rue&quot;, new BooleanToken(true)); // see the Java source for details on parseLiteral() case &#39;f&#39; -&gt; parseLiteral(iterator, &quot;alse&quot;, new BooleanToken(false)); case &#39;n&#39; -&gt; parseLiteral(iterator, &quot;ull&quot;, new NullToken()); case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;+&#39;, &#39;.&#39;, &#39;e&#39;, &#39;E&#39; -&gt; new NumberToken(StringUtils.parseNumber(builder, c, iterator, i -&gt; pushedBack = i)); // see Java source for details on StringUtils.parseNumber case &#39;:&#39; -&gt; { if (possibleObjectName == null) { throw new RuntimeException(); // illegal state - &#39;:&#39; without a preceeding string } ObjectNameToken objectNameToken = new ObjectNameToken(possibleObjectName); possibleObjectName = null; yield objectNameToken; } default -&gt; { if (StringUtils.isWhitespace(c)) { yield null; // ignore whitespace between tokens } throw new RuntimeException(); // unexpected character } }; See JsonParser.java for the full implementation. Test it out for yourself! In the previous articles we developed a serializer and a printer. Now we can reverse the process and take JSON text to produce a stream of JSON tokens. Let’s put this together in jshell. The example use these files: TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java From a terminal with Java 19 installed, run the following (note you’ll need the wget utility): wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/TypeToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonSerializer.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/StringUtils.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonPrinter.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java jshell --enable-preview TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java Inside jshell let’s serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens: var serializer = JsonSerializer.instance(); var printer = JsonPrinter.instance(); var parser = JsonParser.instance(); record Person(String name, int age) {} var person = new Person(&quot;someone&quot;, 28); serializer.serialize(person) // serialize to stream of JsonToken .map(printer::print) // map each JsonToken to a String (as a CharSequence) .map(CharSequence::chars) // map each CharSequence to an IntStream .flatMap(parser::parse) // pass each IntStream to the parser and flatten the resulting stream of tokens .forEach(System.out::println); // print each token to standard out Summary We can now serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens. Next up is deserialization. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy." />
<link rel="canonical" href="https://docs.starburst.io/blog_bej/2022-09-20-bej4-parsing.html" />
<meta property="og:url" content="https://docs.starburst.io/blog_bej/2022-09-20-bej4-parsing.html" />
<meta property="og:site_name" content="Starburst" />
<meta property="og:image" content="https://docs.starburst.io/assets/img/logo/java.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-20T00:00:00-05:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://docs.starburst.io/assets/img/logo/java.png" />
<meta property="twitter:title" content="Parsing" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-20T00:00:00-05:00","datePublished":"2022-09-20T00:00:00-05:00","description":"This is part 4 of the Bleeding edge Java series. Start at the introduction if you haven’t already. Parsing is the process of interpreting free form JSON text and converting it into a stream of JSON tokens. The JSON Spec defines the manner in which parsing should be done: what constitutes whitespace, escape sequences in strings, etc. In short, take a stream of characters and interpret those characters as a stream of JSON tokens. We can define a Java interface for this: public interface JsonParser { Stream&lt;JsonToken&gt; parse(IntStream stream); // Note: Java Strings can be streamed via the chars() method } Instead of a normal Java Stream we need to use an IntStream as we’re dealing with primitive values: characters. Java does not have a CharStream so IntStream will suffice. There are a number of wrinkles we’ll have to deal with when interpreting characters: We sometimes need to look ahead before we know what token type is implied (for literals, strings, numbers) Our library introduces an object name token. This means that when we parse a string we need to wait for the next token. If it’s a : we have to convert the string into an object name. Number tokens can possibly end with a parseable character: , [ {. When this happens we need to reprocess that character. Here is the general flow for parsing JSON text: The code Java streams process an element at a time and don’t allow arbitrary forward/backward access. This limitation would make writing a parser very difficult. Fortunately, a stream can be converted into an Iterator which allows the parser to continue accessing characters in the stream as needed. The stream method iterator() is used to access this iterator whose type has the unfortunately complex name PrimitiveIterator.OfInt. Another issue with Java streams is that it’s not simple to generate a stream with an unknown length. The management of stream ending occurs in the JDK and there aren’t exposed methods to control this. However, you can easily convert an Iterator to a stream. Our parser can create an Iterator internally which can continue to return tokens until parsing is complete and then its hasNext() method can return false. Putting this together we need these variables: PrimitiveIterator.OfInt iterator - the iterator of the character stream being processed LinkedList&lt;JsonToken&gt; tokens - the list of tokens that should be returned from our iterator. We need a list because we will sometimes have more than one token to return. int pushedBack - this is the possibly pushed back character from number parsing or -1 Our parser implementation looks like this: Stream&lt;JsonToken&gt; parse(IntStream stream) { Iterator&lt;JsonToken&gt; tokenIterator = new Iterator&lt;&gt;() { ... }; return StreamSupport.stream(Spliterators.spliteratorUnknownSize(tokenIterator, 0), false); // standard method of converting an Iterator to a stream } The first step in our internal iterator is to prepare our state variables: private final StringBuilder builder = new StringBuilder(); // contains currently being parsed string, number, etc. private final PrimitiveIterator.OfInt iterator = stream.iterator(); // stream of characters being processed as an Iterator private final LinkedList&lt;JsonToken&gt; tokens = new LinkedList&lt;&gt;(); // list of tokens that need to be returned private int pushedBack = -1; // possibly pushed back character from number parsing or -1 The hasNext() implementation for our iterator is straightforward: public boolean hasNext() { return !tokens.isEmpty(); } The majority of the implementation in our iterator will be in the method advanceToNextToken() which advances to the next token in the stream updating the state variables in the process. Before we show this let’s show the implementation for the next() method of our iterator: public JsonToken next() { if (tokens.isEmpty()) { throw new RuntimeException(); } JsonToken result = tokens.removeFirst(); // remove the first token and save it advanceToNextToken(); // advance return result; // return the token } Now we implement advanceToNextToken(). First let’s advance past any whitespace unless there’s a pushed-back character: if (pushedBack &lt; 0) { pushedBack = advanceWhitespace(iterator); // note: advanceWhitespace() can generate a new pushed-back character } Next we loop over characters from the character stream until we have a token. String possibleObjectName = null; // set when a string is processed JsonToken nextToken = null; while ((nextToken == null) &amp;&amp; ((pushedBack &gt;= 0) || iterator.hasNext())) { char c = (char) (((pushedBack &gt;= 0) ? pushedBack : iterator.nextInt()) &amp; 0xffff); pushedBack = -1; ... process character ... } if (possibleObjectName != null) { // wasn&#39;t an object name - we now have to emit this string token first tokens.add(new StringToken(possibleObjectName)); } if (nextToken != null) { tokens.add(nextToken); } We only need to process each character - again using enhanced switch: nextToken = switch (c) { case &#39;{&#39; -&gt; new BeginObjectToken(); case &#39;}&#39; -&gt; new EndObjectToken(); case &#39;[&#39; -&gt; new BeginArrayToken(); case &#39;]&#39; -&gt; new EndArrayToken(); case &#39;,&#39; -&gt; new ValueSeparatorToken(); case &#39;&quot;&#39; -&gt; { if (possibleObjectName != null) { throw new RuntimeException(); // can&#39;t have more than one string } possibleObjectName = StringUtils.parseString(builder, iterator); // it may be an object name so we have to keep parsing yield null; } case &#39;t&#39; -&gt; parseLiteral(iterator, &quot;rue&quot;, new BooleanToken(true)); // see the Java source for details on parseLiteral() case &#39;f&#39; -&gt; parseLiteral(iterator, &quot;alse&quot;, new BooleanToken(false)); case &#39;n&#39; -&gt; parseLiteral(iterator, &quot;ull&quot;, new NullToken()); case &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;-&#39;, &#39;+&#39;, &#39;.&#39;, &#39;e&#39;, &#39;E&#39; -&gt; new NumberToken(StringUtils.parseNumber(builder, c, iterator, i -&gt; pushedBack = i)); // see Java source for details on StringUtils.parseNumber case &#39;:&#39; -&gt; { if (possibleObjectName == null) { throw new RuntimeException(); // illegal state - &#39;:&#39; without a preceeding string } ObjectNameToken objectNameToken = new ObjectNameToken(possibleObjectName); possibleObjectName = null; yield objectNameToken; } default -&gt; { if (StringUtils.isWhitespace(c)) { yield null; // ignore whitespace between tokens } throw new RuntimeException(); // unexpected character } }; See JsonParser.java for the full implementation. Test it out for yourself! In the previous articles we developed a serializer and a printer. Now we can reverse the process and take JSON text to produce a stream of JSON tokens. Let’s put this together in jshell. The example use these files: TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java From a terminal with Java 19 installed, run the following (note you’ll need the wget utility): wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/TypeToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonToken.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonSerializer.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/StringUtils.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonPrinter.java wget -nc https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java jshell --enable-preview TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java Inside jshell let’s serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens: var serializer = JsonSerializer.instance(); var printer = JsonPrinter.instance(); var parser = JsonParser.instance(); record Person(String name, int age) {} var person = new Person(&quot;someone&quot;, 28); serializer.serialize(person) // serialize to stream of JsonToken .map(printer::print) // map each JsonToken to a String (as a CharSequence) .map(CharSequence::chars) // map each CharSequence to an IntStream .flatMap(parser::parse) // pass each IntStream to the parser and flatten the resulting stream of tokens .forEach(System.out::println); // print each token to standard out Summary We can now serialize a Java record into JSON text and then parse that text back into a stream of JSON tokens. Next up is deserialization. We’re hiring Want to be able to use the latest features of Java? We’re hiring! Jordan Zimmerman is a Senior Software Engineer working on Starburst Galaxy.","headline":"Parsing","image":"https://docs.starburst.io/assets/img/logo/java.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://docs.starburst.io/blog_bej/2022-09-20-bej4-parsing.html"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://docs.starburst.io/assets/img/logo/starburst-reverse.png"}},"url":"https://docs.starburst.io/blog_bej/2022-09-20-bej4-parsing.html"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>


<header class="main-header navbar-expand-sm">
  <div class="navbar fixed-top navbar-dark">
    <div class="navbar-left-container">
      <a class="navbar-brand" href="https://www.starburst.io/">
        <img src="/assets/img/logo/starburst_KO-T.png" height="32" alt="Starburst">
      </a>
      <span class="navbar-divider"></span>
      <a href="/" class="header-text">Documentation</a>
    </div>
    
    <div class="nav-item dropdown" id="site-search">
  <div id="dropdownSearchDisplay" aria-labelledby="dropdownSearch">
    <div id="algolia-search">
      <div id="searchbox"></div>
      <div id="refinement-list">
        <h6>Filter:</h6>
      </div>
      <div id="hits"></div>
      <div id="stats"></div>
    </div>
  </div>
</div>

    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
    <nav class="primary-nav">
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-layout navbar-nav mr-auto">
          <li class="nav-item dropdown">
            <a id="get-started"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/get-started/index.html">Get started</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/get-started/concepts.html">Concepts</a>
              <a class="dropdown-item" href="/get-started/architecture.html">Architecture</a>
              <a class="dropdown-item" href="/get-started/data-sources-catalogs.html">Data sources and catalogs</a>
              <a class="dropdown-item" href="/get-started/security.html">Security</a>
              <a class="dropdown-item" href="/get-started/choose-your-starburst-product.html">Choose your Starburst product</a>
              <a class="dropdown-item" href="/data-consumer/index.html">Data consumer</a>
              <a class="dropdown-item" href="/data-engineer/index.html">Data engineer</a>
              <a class="dropdown-item" href="/platform-administrator/index.html">Platform administrator</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-galaxy"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Starburst Galaxy" data-is-click="false"
              href="/starburst-galaxy/index.html">Starburst Galaxy</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-galaxy/query/index.html">Query</a>
              <a class="dropdown-item" href="/starburst-galaxy/catalogs/index.html">Catalogs</a>
              <a class="dropdown-item" href="/starburst-galaxy/clusters/index.html">Clusters</a>
              <a class="dropdown-item" href="/starburst-galaxy/sql/index.html">SQL</a>
              <a class="dropdown-item" href="/starburst-galaxy/admin/index.html">Admin</a>
              <a class="dropdown-item" href="/starburst-galaxy/access-control/index.html">Access control</a>
              <a class="dropdown-item" href="/starburst-galaxy/cloud-settings/index.html">Cloud settings</a>
              <a class="dropdown-item" href="/starburst-galaxy/security/index.html">Security</a>
              <a class="dropdown-item" href="/starburst-galaxy/sso/index.html">Single sign-on</a>
              <a class="dropdown-item" href="/starburst-galaxy/api.html">API</a>
              <a class="dropdown-item" href="/starburst-galaxy/tutorials/index.html">Tutorials</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-enterprise"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/starburst-enterprise/index.html">Starburst Enterprise</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-enterprise/try/index.html">Try Starburst Enterprise</a>
              <a class="dropdown-item" href="/starburst-enterprise/web-ui/index.html">Web UI</a>
              <a class="dropdown-item" href="/starburst-enterprise/sql.html">SQL</a>
              <a class="dropdown-item" href="/starburst-enterprise/admin-topics/index.html">Administration</a>
              <a class="dropdown-item" href="/starburst-enterprise/k8s/index.html">Kubernetes deployments</a>
              <a class="dropdown-item" href="/starburst-enterprise/starburst-admin/index.html">Starburst Admin</a>
              <a class="dropdown-item" href="/latest/index.html">Reference documentation</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="ecosystems"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/ecosystems/index.html">Ecosystems</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/ecosystems/amazon/index.html">Amazon AWS</a>
              <a class="dropdown-item" href="/ecosystems/google/index.html">Google Cloud</a>
              <a class="dropdown-item" href="/ecosystems/microsoft/index.html">Microsoft Azure</a>
              <a class="dropdown-item" href="/ecosystems/redhat/index.html">Red Hat OpenShift</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="resources"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="resources" data-is-click="false"
              href="/resources.html">Resources</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/support.html">Support</a>
              <a class="dropdown-item" href="/security/index.html">Security</a>
              <a class="dropdown-item" href="/blog/index.html">Developer blog</a>
              <a class="dropdown-item" href="/videos/index.html">Video library</a>
              <a class="dropdown-item" href="/glossary.html">Glossary</a>
              <a class="dropdown-item" href="https://www.trinoforum.org/">Trino forum</a>
            </div>
          </li>
        </ul>
      </div>
    </nav>
</header>

    <div class="landing-page">
        <div class="sep-hero">
  <div class="container sep-parent">
    <div class="row">
      <div class="col-md-12">
        <h1><a href="/blog/">Starburst developer blog</a></h1>
        <p class="lead">The latest news from our users, engineers, writers, and
        product folks for all our peers and friends out there.</p>
        <p>Want even more updates and information? Go to the
          <a href="https://blog.starburst.io/">Starburst company blog</a>.</p>
      </div>
    </div>
  </div>
</div>

  


<div class="content container-fluid post-container clearfix spacer-30">

  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="container">
      <div class="row">

        <div class="col-xl-3">
          <h3>Contents</h3>
          <ul class="list-group">
            
              
                <a class="list-group-item" href="/blog/2022-09-20-bej0-introduction.html">Bleeding edge Java</a>
              
            
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej1-design.html">Designing a JSON model</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej2-serialization.html">Serialization</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej3-printing.html">Printing</a>
              
            
              
                <li class="list-group-item active">Parsing</li>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej5-deserialization.html">Deserialization part 1</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej6-deserialization.html">Deserialization part 2</a>
              
            
              
                <a class="list-group-item" href="/blog_bej/2022-09-20-bej7-conclusion.html">Conclusion</a>
              
            
          </ul>
        </div>

        <div class="col-xl-9">
          <header class="post-header">
            <h1 class="post-title p-name" itemprop="name headline">
              Parsing</h1>
            <p class="post-meta">
              <time class="dt-published" abbrtime="2022-09-20T00:00:00-05:00" itemprop="datePublished">
                Sep 20, 2022
              </time> |

     Jordan Zimmerman
     
     
     <a href="https://github.com/randgalt" target="_blank"><i class="fab fa-github"></i></a>
     
     
</p>
          </header>

          <div class="content width clearfix" itemprop="articleBody"><img src="../assets/img/logo/java.png" style="float: right;"><p><em>This is part 4 of the Bleeding edge Java series. <a href="/blog/2022-09-20-bej0-introduction.html">Start at the
introduction</a> if you haven’t
already.</em></p>

<p>Parsing is the process of interpreting free form JSON text and converting it
into a stream of JSON tokens. The <a href="https://www.rfc-editor.org/rfc/rfc8259" target="_blank">JSON
Spec</a> defines the manner in which
parsing should be done: what constitutes whitespace, escape sequences in
strings, etc. In short, take a stream of characters and interpret those
characters as a stream of JSON tokens.</p>

<p>We can define a Java interface for this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JsonParser</span>
<span class="o">{</span>
    <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">IntStream</span> <span class="n">stream</span><span class="o">);</span>  <span class="c1">// Note: Java Strings can be streamed via the chars() method</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instead of a normal Java <code class="language-plaintext highlighter-rouge">Stream</code> we need to use an <code class="language-plaintext highlighter-rouge">IntStream</code> as we’re dealing
with primitive values: characters. Java does not have a <code class="language-plaintext highlighter-rouge">CharStream</code> so
<code class="language-plaintext highlighter-rouge">IntStream</code> will suffice.</p>

<p>There are a number of wrinkles we’ll have to deal with when interpreting
characters:</p>

<ul>
  <li>We sometimes need to look ahead before we know what token type is implied (for
literals, strings, numbers)</li>
  <li>Our library introduces an object name token. This means that when we parse a
string we need to wait for the next token. If it’s a <code class="language-plaintext highlighter-rouge">:</code> we have to convert
the string into an object name.</li>
  <li>Number tokens can possibly end with a parseable character: <code class="language-plaintext highlighter-rouge">,</code> <code class="language-plaintext highlighter-rouge">[</code> <code class="language-plaintext highlighter-rouge">{</code>. When
this happens we need to reprocess that character.</li>
</ul>

<p>Here is the general flow for parsing JSON text:</p>

<p><img src="../assets/img/blog/bej-parse-flow.png" alt="" /></p>

<h2 id="the-code">The code</h2>

<p>Java streams process an element at a time and don’t allow arbitrary
forward/backward access. This limitation would make writing a parser very
difficult. Fortunately, a stream can be converted into an 
<a href="https://download.java.net/java/early_access/jdk19/docs/api/java.base/java/util/Iterator.html" target="_blank">Iterator</a> 
which allows the parser to continue accessing characters in the stream as needed. The stream
method <code class="language-plaintext highlighter-rouge">iterator()</code> is used to access this iterator whose type has the
unfortunately complex name <code class="language-plaintext highlighter-rouge">PrimitiveIterator.OfInt</code>.</p>

<p>Another issue with Java streams is that it’s not simple to generate a stream
with an unknown length. The management of stream ending occurs in the JDK and
there aren’t exposed methods to control this. However, you can easily convert an
Iterator to a stream. Our parser can create an Iterator internally which can
continue to return tokens until parsing is complete and then its <code class="language-plaintext highlighter-rouge">hasNext()</code>
method can return <code class="language-plaintext highlighter-rouge">false</code>.</p>

<p>Putting this together we need these variables:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">PrimitiveIterator.OfInt iterator</code> - the iterator of the character stream
being processed</li>
  <li><code class="language-plaintext highlighter-rouge">LinkedList&lt;JsonToken&gt; tokens</code> - the list of tokens that should be returned from
our iterator. We need a list because we will sometimes have more than one token to return.</li>
  <li><code class="language-plaintext highlighter-rouge">int pushedBack</code> - this is the possibly pushed back character from number
parsing or -1</li>
</ul>

<p>Our parser implementation looks like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">IntStream</span> <span class="n">stream</span><span class="o">)</span>
<span class="o">{</span>
    <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="n">tokenIterator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">};</span>
    <span class="k">return</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="nc">Spliterators</span><span class="o">.</span><span class="na">spliteratorUnknownSize</span><span class="o">(</span><span class="n">tokenIterator</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="kc">false</span><span class="o">);</span>  <span class="c1">// standard method of converting an Iterator to a stream</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The first step in our internal iterator is to prepare our state variables:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">final</span> <span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>          <span class="c1">// contains currently being parsed string, number, etc.</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">PrimitiveIterator</span><span class="o">.</span><span class="na">OfInt</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="c1">// stream of characters being processed as an Iterator</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">JsonToken</span><span class="o">&gt;</span> <span class="n">tokens</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>    <span class="c1">// list of tokens that need to be returned</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">pushedBack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>                                        <span class="c1">// possibly pushed back character from number parsing or -1</span>
</code></pre></div></div>

<p>The <a href="https://download.java.net/java/early_access/jdk19/docs/api/java.base/java/util/Iterator.html#hasNext()" target="_blank"><code class="language-plaintext highlighter-rouge">hasNext()</code></a> 
implementation for our iterator is straightforward:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">tokens</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The majority of the implementation in our iterator will be in the method
<code class="language-plaintext highlighter-rouge">advanceToNextToken()</code> which advances to the next token in the stream updating
the state variables in the process. Before we show this let’s show the
implementation for the <a href="https://download.java.net/java/early_access/jdk19/docs/api/java.base/java/util/Iterator.html#next()" target="_blank"><code class="language-plaintext highlighter-rouge">next()</code></a> 
method of our iterator:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">JsonToken</span> <span class="nf">next</span><span class="o">()</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tokens</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">JsonToken</span> <span class="n">result</span> <span class="o">=</span> <span class="n">tokens</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>    <span class="c1">// remove the first token and save it</span>
    <span class="n">advanceToNextToken</span><span class="o">();</span>                       <span class="c1">// advance</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>                              <span class="c1">// return the token</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we implement <code class="language-plaintext highlighter-rouge">advanceToNextToken()</code>. First let’s advance past any whitespace
unless there’s a pushed-back character:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">pushedBack</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">pushedBack</span> <span class="o">=</span> <span class="n">advanceWhitespace</span><span class="o">(</span><span class="n">iterator</span><span class="o">);</span>   <span class="c1">// note: advanceWhitespace() can generate a new pushed-back character</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Next we loop over characters from the character stream until we have a token.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">possibleObjectName</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>   <span class="c1">// set when a string is processed</span>
<span class="nc">JsonToken</span> <span class="n">nextToken</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextToken</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">pushedBack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">||</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()))</span> <span class="o">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(((</span><span class="n">pushedBack</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">?</span> <span class="n">pushedBack</span> <span class="o">:</span> <span class="n">iterator</span><span class="o">.</span><span class="na">nextInt</span><span class="o">())</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="o">);</span>
    <span class="n">pushedBack</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

    <span class="o">...</span> <span class="n">process</span> <span class="n">character</span> <span class="o">...</span>
<span class="o">}</span>
<span class="k">if</span> <span class="o">(</span><span class="n">possibleObjectName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// wasn't an object name - we now have to emit this string token first</span>
    <span class="n">tokens</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringToken</span><span class="o">(</span><span class="n">possibleObjectName</span><span class="o">));</span>
<span class="o">}</span>
<span class="k">if</span> <span class="o">(</span><span class="n">nextToken</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tokens</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nextToken</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We only need to process each character - again using enhanced switch:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nextToken</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="sc">'{'</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">BeginObjectToken</span><span class="o">();</span>
    <span class="k">case</span> <span class="sc">'}'</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">EndObjectToken</span><span class="o">();</span>
    <span class="k">case</span> <span class="sc">'['</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">BeginArrayToken</span><span class="o">();</span>
    <span class="k">case</span> <span class="sc">']'</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">EndArrayToken</span><span class="o">();</span>
    <span class="k">case</span> <span class="sc">','</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">ValueSeparatorToken</span><span class="o">();</span>
    <span class="k">case</span> <span class="sc">'"'</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">possibleObjectName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>   <span class="c1">// can't have more than one string </span>
        <span class="o">}</span>
        <span class="n">possibleObjectName</span> <span class="o">=</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">parseString</span><span class="o">(</span><span class="n">builder</span><span class="o">,</span> <span class="n">iterator</span><span class="o">);</span>    <span class="c1">// it may be an object name so we have to keep parsing</span>
        <span class="n">yield</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="sc">'t'</span> <span class="o">-&gt;</span> <span class="n">parseLiteral</span><span class="o">(</span><span class="n">iterator</span><span class="o">,</span> <span class="s">"rue"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BooleanToken</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span>    <span class="c1">// see the Java source for details on parseLiteral()</span>
    <span class="k">case</span> <span class="sc">'f'</span> <span class="o">-&gt;</span> <span class="n">parseLiteral</span><span class="o">(</span><span class="n">iterator</span><span class="o">,</span> <span class="s">"alse"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BooleanToken</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
    <span class="k">case</span> <span class="sc">'n'</span> <span class="o">-&gt;</span> <span class="n">parseLiteral</span><span class="o">(</span><span class="n">iterator</span><span class="o">,</span> <span class="s">"ull"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">NullToken</span><span class="o">());</span>
    <span class="k">case</span> <span class="sc">'0'</span><span class="o">,</span> <span class="sc">'1'</span><span class="o">,</span> <span class="sc">'2'</span><span class="o">,</span> <span class="sc">'3'</span><span class="o">,</span> <span class="sc">'4'</span><span class="o">,</span> <span class="sc">'5'</span><span class="o">,</span> <span class="sc">'6'</span><span class="o">,</span> <span class="sc">'7'</span><span class="o">,</span> <span class="sc">'8'</span><span class="o">,</span> <span class="sc">'9'</span><span class="o">,</span> <span class="sc">'-'</span><span class="o">,</span> <span class="sc">'+'</span><span class="o">,</span> <span class="sc">'.'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'E'</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">NumberToken</span><span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">parseNumber</span><span class="o">(</span><span class="n">builder</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">iterator</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="n">pushedBack</span> <span class="o">=</span> <span class="n">i</span><span class="o">));</span> <span class="c1">// see Java source for details on StringUtils.parseNumber</span>
    <span class="k">case</span> <span class="sc">':'</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">possibleObjectName</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>   <span class="c1">// illegal state - ':' without a preceeding string</span>
        <span class="o">}</span>
        <span class="nc">ObjectNameToken</span> <span class="n">objectNameToken</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectNameToken</span><span class="o">(</span><span class="n">possibleObjectName</span><span class="o">);</span>
        <span class="n">possibleObjectName</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">yield</span> <span class="n">objectNameToken</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isWhitespace</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">yield</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ignore whitespace between tokens</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>   <span class="c1">// unexpected character</span>
    <span class="o">}</span>
<span class="o">};</span>
</code></pre></div></div>

<p>See
<a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java" target="_blank">JsonParser.java</a>
for the full implementation.</p>

<h2 id="test-it-out-for-yourself">Test it out for yourself!</h2>

<p>In the previous articles we developed a serializer and a printer. Now we can
reverse the process and take JSON text to produce a stream of JSON tokens. Let’s
put this together in jshell. The example use these files:</p>

<ul>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/TypeToken.java" target="_blank">TypeToken.java</a></li>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonToken.java" target="_blank">JsonToken.java</a></li>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonSerializer.java" target="_blank">JsonSerializer.java</a></li>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/StringUtils.java" target="_blank">StringUtils.java</a></li>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonPrinter.java" target="_blank">JsonPrinter.java</a></li>
  <li><a href="https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java" target="_blank">JsonParser.java</a></li>
</ul>

<p>From a terminal with <a href="https://jdk.java.net/19/" target="_blank">Java 19</a> installed, run the following (note you’ll need the <a href="https://wiki.archiveteam.org/index.php/Wget_installation" target="_blank">wget utility</a>):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/TypeToken.java
wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonToken.java
wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonSerializer.java
wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/StringUtils.java
wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonPrinter.java
wget <span class="nt">-nc</span> https://raw.githubusercontent.com/starburstdata/developer-blog-assets/main/bleeding-edge-java/code/JsonParser.java
jshell <span class="nt">--enable-preview</span> TypeToken.java JsonToken.java JsonSerializer.java StringUtils.java JsonPrinter.java JsonParser.java
</code></pre></div></div>

<p>Inside jshell let’s serialize a Java record into JSON text and then parse that
text back into a stream of JSON tokens:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">serializer</span> <span class="o">=</span> <span class="nc">JsonSerializer</span><span class="o">.</span><span class="na">instance</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">printer</span> <span class="o">=</span> <span class="nc">JsonPrinter</span><span class="o">.</span><span class="na">instance</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">parser</span> <span class="o">=</span> <span class="nc">JsonParser</span><span class="o">.</span><span class="na">instance</span><span class="o">();</span>

<span class="n">record</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{}</span>
<span class="kt">var</span> <span class="n">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"someone"</span><span class="o">,</span> <span class="mi">28</span><span class="o">);</span>

<span class="n">serializer</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">person</span><span class="o">)</span>        <span class="c1">// serialize to stream of JsonToken</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">printer:</span><span class="o">:</span><span class="n">print</span><span class="o">)</span>            <span class="c1">// map each JsonToken to a String (as a CharSequence)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">CharSequence:</span><span class="o">:</span><span class="n">chars</span><span class="o">)</span>       <span class="c1">// map each CharSequence to an IntStream</span>
    <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="nl">parser:</span><span class="o">:</span><span class="n">parse</span><span class="o">)</span>         <span class="c1">// pass each IntStream to the parser and flatten the resulting stream of tokens</span>
    <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>  <span class="c1">// print each token to standard out</span>
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>We can now serialize a Java record into JSON text and then parse that text back
into a stream of JSON tokens. Next up is <a href="/blog_bej/2022-09-20-bej5-deserialization.html">deserialization</a>.</p>

<h2 id="were-hiring">We’re hiring</h2>

<p>Want to be able to use the latest features of Java? <a href="https://www.starburst.io/careers/" target="_blank">We’re
hiring!</a></p>

<hr />

<p>Jordan Zimmerman is a Senior Software Engineer working on <a href="https://www.starburst.io/platform/starburst-galaxy/" target="_blank">Starburst
Galaxy</a>.</p>

          </div>
        </div>
      </div>
    </div>

    <a class="u-url" href="/blog_bej/2022-09-20-bej4-parsing.html" hidden></a>
  </article>

</div>



    </div>


<div style="margin-bottom: 50px"></div><footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-6">
        <p style="font-weight:900">Resources</b></p>
        <ul>
          <li class="footer-item"><a href="/videos/index.html">Video library</a></li>
          <li class="footer-item"><a href="/glossary.html">Glossary</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/info/oreilly-trino-guide/" target="_blank">Free O'Reilly book - Trino: The Definitive Guide</a></li>
          <li class="footer-item"><a href="https://trino.io/broadcast/" target="_blank">Trino Community Broadcast</a></li>
          <li class="footer-item"><a href="https://trinoforum.org" target="_blank">Trino Forum</a></li>
          <li class="footer-item"><a href="https://blog.starburstdata.com/" target="_blank">Starburst blog</a></li>
        </ul>
      </div>
      <div class="col-md-3">
        <p style="font-weight:900">Contact and more</p>
        <ul>
          <li class="footer-item"><a href="https://www.starburst.io" target="_blank">Starburst</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/#download" target="_blank">Start a trial</a></li>
          <li class="footer-item"><a href="/support.html" target="_blank">Get support</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/contact/" target="_blank">Contact us</a></li>
        </ul>
      </div>
      <div class="col-md-3" style="text-align:right;">
        <a href="https://www.starburst.io/" target="_blank"><img src="/assets/img/logo/starburst-reverse.png" height="60" alt=" Starburst" style="margin-bottom:20px;"></a>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#copyright">Copyright © 2017-2022<br> Starburst Data</a>
        </li>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#trademarks">Trademark information</a>
        </li>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 center spacer-30">
          <a href="https://twitter.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-twitter"></i></a>
          <a href="https://linkedin.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-linkedin"></i></a>
          <a href="https://www.youtube.com/channel/UCXjkuWSO9CV_cSI3Mvo4a4w" target="_blank" class="footer-icon"><i class="fab fa-youtube"></i></a>
          <a href="https://github.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-github"></i></a>
      </div>
    </div>
  </div>
</footer>
  <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/popper.min.js"></script>
  <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/assets/js/mdb.min.js"></script>
  <script type="text/javascript" src="/assets/js/custom.js"></script>
  <script type="text/javascript" src="/assets/js/algolia.js"></script>
  <script type="text/javascript" src="/assets/js/search-box.js"></script>
  <script type="text/javascript" src="/assets/js/search-results.js"></script>
</body>
</html>
