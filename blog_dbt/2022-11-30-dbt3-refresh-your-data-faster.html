<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Starburst | Refresh your data faster using incremental models</title>
    <meta name="viewport" content="width=device-width">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Starburst - Refresh your data faster using incremental models">
    <meta property="og:description" content="Your hub to all knowledge about Starburst products.">
    <meta property="og:image" content="/assets/img/starburst-og-image.png">

    <link rel="stylesheet" href="/assets/fontawesome/css/all.css">
    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/assets/css/mdb.min.css">
    <link rel="stylesheet" href="/assets/css/highlight.css">
    <link rel="stylesheet" href="/assets/css/fonts.css">
    <link rel="stylesheet" href="/assets/css/style.css">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114610397-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-114610397-1');
</script>

<script type="text/javascript">
    window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=document.createElement("script");r.type="text/javascript",r.async=!0,r.src="https://cdn.heapanalytics.com/js/heap-"+e+".js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(r,a);for(var n=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],o=0;o<p.length;o++)heap[p[o]]=n(p[o])};
    heap.load("588835629");
</script>
<script>
  var ALGOLIA_INSIGHTS_SRC = "https://cdn.jsdelivr.net/npm/search-insights@2.2.1";

  !function(e,a,t,n,s,i,c){e.AlgoliaAnalyticsObject=s,e[s]=e[s]||function(){
  (e[s].queue=e[s].queue||[]).push(arguments)},i=a.createElement(t),c=a.getElementsByTagName(t)[0],
  i.async=1,i.src=n,c.parentNode.insertBefore(i,c)
  }(window,document,"script",ALGOLIA_INSIGHTS_SRC,"aa");
</script>
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Refresh your data faster using incremental models | Starburst</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Refresh your data faster using incremental models" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is part three of the lakehouse ETL with dbt and Trino series. Start at the introduction if you haven’t already. Incremental models To refresh data faster, you can use incremental models which limit the amount of data loaded to the target table and significantly reduces loading time. The first time an incremental model is run, the table is created by transforming all rows from the source. On subsequent runs, dbt transforms only the rows in your model that you tell dbt to filter for inserting them into target table. Incremental models vastly improve performance and reduces compute costs. To use incremental models just add materialized=&#39;incremental&#39; into your model configuration: {{ config( materialized=&#39;incremental&#39;, unique_key=&#39;id&#39; ) }} SELECT * FROM ... A unique_key determines whether a record has new values and should be updated. By using unique_key, you can ensure that each row from the source table is represented by a single row in your incremental model, without duplicates. Not specifying a unique_key results in append-only behavior, which means dbt inserts all rows returned by the model’s SQL into the preexisting target table without regard for whether the rows represent duplicates. In cases where you need multiple columns in combination to uniquely identify each row, you can pass these columns as a list similar to unique_key = [&#39;id&#39;, &#39;user_id&#39;]. Reduce data for processing To tell dbt which rows it should transform on an incremental run, wrap valid SQL that filters for these rows in the is_incremental() macro. This filter is only applied on subsequent incremental runs. Include this macro in the model configuration: SELECT * FROM ... {% if is_incremental() %} WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Incremental strategies The dbt-trino adapter supports multiple incremental strategies which instruct how the data is loaded into the target table. Different approaches may vary by effectiveness depending on the volume of data, the reliability of your unique_key, or the availability of certain features. dbt-trino supports the following incremental strategies: append (default) delete+insert merge append The default incremental strategy is append, which only adds the new records based on the condition specified in the is_incremental() conditional block. It can be configured without a unique_key, since it only inserts the data into the target table. {{ config( materialized = &#39;incremental&#39; ) }} SELECT * FROM ... delete+insert Through the delete+insert incremental strategy, you can instruct dbt to use a two-step incremental approach. It deletes the records detected through the configured is_incremental() block before re-inserting them. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;delete+insert&#39;, ) }} SELECT * FROM ... merge Through the merge incremental strategy, dbt-trino constructs a MERGE statement which inserts new and updates existing records based on the unique key. Note that some connectors in Trino have limited or no support for MERGE. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;merge&#39;, ) }} SELECT * FROM ... Refresh data faster on your lakehouse Refresh your data faster using the incremental models described. Since you only need to insert new records that appeared from the day before, based on the event_time column, loading the clicks data into the src_clicks view in the data lake could be an append incremental strategy. {{ config( materialized=&#39;incremental&#39; ) }} with source as ( SELECT * FROM {{ source(&#39;website&#39;, &#39;clicks&#39;) }} ), renamed as ( SELECT visitorid, useragent, language, event, cast(from_iso8601_timestamp(eventtime) as timestamp(6) with time zone) AS eventtime, page, referrer FROM source ) SELECT * FROM renamed {% if is_incremental() %} -- this filter is only applied on an incremental run WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Now, create a customer_sessions table, which is used to create the next table. It calculates when a particular session has started and ended. SELECT cookie_id, last_value(customer_id) IGNORE NULLS OVER ( PARTITION BY cookie_id ORDER BY session_started ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS customer_id, session_started, lead(session_started, 1, current_timestamp(6)) OVER (PARTITION BY cookie_id ORDER BY session_started asc) AS session_ended FROM {{ ref(&quot;src_sessions&quot;) }} Since the sessionization (the calculating and connecting clicks with sessions) can affect older sessions, you should use the MERGE incremental strategy to update existing records and insert only new records into the sessionized_clicks table based on the clickid column. {{ config( materialized=&#39;incremental&#39;, unique_key=&quot;clickid&quot;, incremental_strategy=&#39;merge&#39;, ) }} with sessions as ( SELECT date_diff(&#39;hour&#39;, lag(c.eventtime) OVER w, c.eventtime) &gt; 1 AS new_session, {{ dbt_utils.star(ref(&quot;src_clicks&quot;), &quot;c&quot;) }}, {{ dbt_utils.star(ref(&quot;customer_sessions&quot;), &quot;s&quot;, [&quot;session_started&quot;, &quot;session_ended&quot;]) }}, first_value(c.referrer) IGNORE NULLS OVER (PARTITION BY s.customer_id ORDER BY c.eventtime ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS channel, row_number() OVER w AS clickid, min(eventtime) OVER w AS session_started, max(eventtime) OVER w AS session_ended FROM {{ ref(&quot;src_clicks&quot;) }} c JOIN {{ ref(&quot;customer_sessions&quot;) }} s ON c.visitorid = s.cookie_id AND c.eventtime between s.session_started AND s.session_ended window w AS ( PARTITION BY c.visitorid ORDER BY c.eventtime ) ), sequenced_sessions as ( SELECT {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }}, sum(if(new_session, 1, 0)) OVER w AS session_sequence, clickid, customer_id, session_started, session_ended, channel FROM sessions WINDOW w AS ( PARTITION BY visitorid ORDER BY eventtime ) ) SELECT visitorid || &#39;_&#39; || cast(session_sequence as varchar) || &#39;_&#39; || cast(clickid as varchar) AS clickid, visitorid || &#39;_&#39; || cast(session_sequence as varchar) AS sessionid, customer_id, session_started, session_ended, channel, {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }} FROM sequenced_sessions Summary dbt and Trino are well maintained and trusted open source projects with thrilling communities that are always ready to learn more and expand the ecosystem. Starburst improves the landscape of broad Trino features and capabilities by offering enhanced built-in security systems, SaaS connectors, UI and much more. If you want to learn more about dbt, Trino, or Starburst and how they coexist, drop us a message on the Trino #python-client or the dbt #db-presto-trino Slack channels. Don’t hesitate to ping us directly on Slack, as well. Thanks, Przemek and Michiel" />
<meta property="og:description" content="This is part three of the lakehouse ETL with dbt and Trino series. Start at the introduction if you haven’t already. Incremental models To refresh data faster, you can use incremental models which limit the amount of data loaded to the target table and significantly reduces loading time. The first time an incremental model is run, the table is created by transforming all rows from the source. On subsequent runs, dbt transforms only the rows in your model that you tell dbt to filter for inserting them into target table. Incremental models vastly improve performance and reduces compute costs. To use incremental models just add materialized=&#39;incremental&#39; into your model configuration: {{ config( materialized=&#39;incremental&#39;, unique_key=&#39;id&#39; ) }} SELECT * FROM ... A unique_key determines whether a record has new values and should be updated. By using unique_key, you can ensure that each row from the source table is represented by a single row in your incremental model, without duplicates. Not specifying a unique_key results in append-only behavior, which means dbt inserts all rows returned by the model’s SQL into the preexisting target table without regard for whether the rows represent duplicates. In cases where you need multiple columns in combination to uniquely identify each row, you can pass these columns as a list similar to unique_key = [&#39;id&#39;, &#39;user_id&#39;]. Reduce data for processing To tell dbt which rows it should transform on an incremental run, wrap valid SQL that filters for these rows in the is_incremental() macro. This filter is only applied on subsequent incremental runs. Include this macro in the model configuration: SELECT * FROM ... {% if is_incremental() %} WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Incremental strategies The dbt-trino adapter supports multiple incremental strategies which instruct how the data is loaded into the target table. Different approaches may vary by effectiveness depending on the volume of data, the reliability of your unique_key, or the availability of certain features. dbt-trino supports the following incremental strategies: append (default) delete+insert merge append The default incremental strategy is append, which only adds the new records based on the condition specified in the is_incremental() conditional block. It can be configured without a unique_key, since it only inserts the data into the target table. {{ config( materialized = &#39;incremental&#39; ) }} SELECT * FROM ... delete+insert Through the delete+insert incremental strategy, you can instruct dbt to use a two-step incremental approach. It deletes the records detected through the configured is_incremental() block before re-inserting them. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;delete+insert&#39;, ) }} SELECT * FROM ... merge Through the merge incremental strategy, dbt-trino constructs a MERGE statement which inserts new and updates existing records based on the unique key. Note that some connectors in Trino have limited or no support for MERGE. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;merge&#39;, ) }} SELECT * FROM ... Refresh data faster on your lakehouse Refresh your data faster using the incremental models described. Since you only need to insert new records that appeared from the day before, based on the event_time column, loading the clicks data into the src_clicks view in the data lake could be an append incremental strategy. {{ config( materialized=&#39;incremental&#39; ) }} with source as ( SELECT * FROM {{ source(&#39;website&#39;, &#39;clicks&#39;) }} ), renamed as ( SELECT visitorid, useragent, language, event, cast(from_iso8601_timestamp(eventtime) as timestamp(6) with time zone) AS eventtime, page, referrer FROM source ) SELECT * FROM renamed {% if is_incremental() %} -- this filter is only applied on an incremental run WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Now, create a customer_sessions table, which is used to create the next table. It calculates when a particular session has started and ended. SELECT cookie_id, last_value(customer_id) IGNORE NULLS OVER ( PARTITION BY cookie_id ORDER BY session_started ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS customer_id, session_started, lead(session_started, 1, current_timestamp(6)) OVER (PARTITION BY cookie_id ORDER BY session_started asc) AS session_ended FROM {{ ref(&quot;src_sessions&quot;) }} Since the sessionization (the calculating and connecting clicks with sessions) can affect older sessions, you should use the MERGE incremental strategy to update existing records and insert only new records into the sessionized_clicks table based on the clickid column. {{ config( materialized=&#39;incremental&#39;, unique_key=&quot;clickid&quot;, incremental_strategy=&#39;merge&#39;, ) }} with sessions as ( SELECT date_diff(&#39;hour&#39;, lag(c.eventtime) OVER w, c.eventtime) &gt; 1 AS new_session, {{ dbt_utils.star(ref(&quot;src_clicks&quot;), &quot;c&quot;) }}, {{ dbt_utils.star(ref(&quot;customer_sessions&quot;), &quot;s&quot;, [&quot;session_started&quot;, &quot;session_ended&quot;]) }}, first_value(c.referrer) IGNORE NULLS OVER (PARTITION BY s.customer_id ORDER BY c.eventtime ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS channel, row_number() OVER w AS clickid, min(eventtime) OVER w AS session_started, max(eventtime) OVER w AS session_ended FROM {{ ref(&quot;src_clicks&quot;) }} c JOIN {{ ref(&quot;customer_sessions&quot;) }} s ON c.visitorid = s.cookie_id AND c.eventtime between s.session_started AND s.session_ended window w AS ( PARTITION BY c.visitorid ORDER BY c.eventtime ) ), sequenced_sessions as ( SELECT {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }}, sum(if(new_session, 1, 0)) OVER w AS session_sequence, clickid, customer_id, session_started, session_ended, channel FROM sessions WINDOW w AS ( PARTITION BY visitorid ORDER BY eventtime ) ) SELECT visitorid || &#39;_&#39; || cast(session_sequence as varchar) || &#39;_&#39; || cast(clickid as varchar) AS clickid, visitorid || &#39;_&#39; || cast(session_sequence as varchar) AS sessionid, customer_id, session_started, session_ended, channel, {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }} FROM sequenced_sessions Summary dbt and Trino are well maintained and trusted open source projects with thrilling communities that are always ready to learn more and expand the ecosystem. Starburst improves the landscape of broad Trino features and capabilities by offering enhanced built-in security systems, SaaS connectors, UI and much more. If you want to learn more about dbt, Trino, or Starburst and how they coexist, drop us a message on the Trino #python-client or the dbt #db-presto-trino Slack channels. Don’t hesitate to ping us directly on Slack, as well. Thanks, Przemek and Michiel" />
<link rel="canonical" href="https://www.starburst.io/blog/2022-11-30-dbt3-refresh-your-data-faster-html/" />
<meta property="og:url" content="https://www.starburst.io/blog/2022-11-30-dbt3-refresh-your-data-faster-html/" />
<meta property="og:site_name" content="Starburst" />
<meta property="og:image" content="https://docs.starburst.io/assets/img/logo/dbt.svg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-11-30T00:00:00-06:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://docs.starburst.io/assets/img/logo/dbt.svg" />
<meta property="twitter:title" content="Refresh your data faster using incremental models" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-30T00:00:00-06:00","datePublished":"2022-11-30T00:00:00-06:00","description":"This is part three of the lakehouse ETL with dbt and Trino series. Start at the introduction if you haven’t already. Incremental models To refresh data faster, you can use incremental models which limit the amount of data loaded to the target table and significantly reduces loading time. The first time an incremental model is run, the table is created by transforming all rows from the source. On subsequent runs, dbt transforms only the rows in your model that you tell dbt to filter for inserting them into target table. Incremental models vastly improve performance and reduces compute costs. To use incremental models just add materialized=&#39;incremental&#39; into your model configuration: {{ config( materialized=&#39;incremental&#39;, unique_key=&#39;id&#39; ) }} SELECT * FROM ... A unique_key determines whether a record has new values and should be updated. By using unique_key, you can ensure that each row from the source table is represented by a single row in your incremental model, without duplicates. Not specifying a unique_key results in append-only behavior, which means dbt inserts all rows returned by the model’s SQL into the preexisting target table without regard for whether the rows represent duplicates. In cases where you need multiple columns in combination to uniquely identify each row, you can pass these columns as a list similar to unique_key = [&#39;id&#39;, &#39;user_id&#39;]. Reduce data for processing To tell dbt which rows it should transform on an incremental run, wrap valid SQL that filters for these rows in the is_incremental() macro. This filter is only applied on subsequent incremental runs. Include this macro in the model configuration: SELECT * FROM ... {% if is_incremental() %} WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Incremental strategies The dbt-trino adapter supports multiple incremental strategies which instruct how the data is loaded into the target table. Different approaches may vary by effectiveness depending on the volume of data, the reliability of your unique_key, or the availability of certain features. dbt-trino supports the following incremental strategies: append (default) delete+insert merge append The default incremental strategy is append, which only adds the new records based on the condition specified in the is_incremental() conditional block. It can be configured without a unique_key, since it only inserts the data into the target table. {{ config( materialized = &#39;incremental&#39; ) }} SELECT * FROM ... delete+insert Through the delete+insert incremental strategy, you can instruct dbt to use a two-step incremental approach. It deletes the records detected through the configured is_incremental() block before re-inserting them. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;delete+insert&#39;, ) }} SELECT * FROM ... merge Through the merge incremental strategy, dbt-trino constructs a MERGE statement which inserts new and updates existing records based on the unique key. Note that some connectors in Trino have limited or no support for MERGE. {{ config( materialized = &#39;incremental&#39;, unique_key=&#39;user_id&#39;, incremental_strategy=&#39;merge&#39;, ) }} SELECT * FROM ... Refresh data faster on your lakehouse Refresh your data faster using the incremental models described. Since you only need to insert new records that appeared from the day before, based on the event_time column, loading the clicks data into the src_clicks view in the data lake could be an append incremental strategy. {{ config( materialized=&#39;incremental&#39; ) }} with source as ( SELECT * FROM {{ source(&#39;website&#39;, &#39;clicks&#39;) }} ), renamed as ( SELECT visitorid, useragent, language, event, cast(from_iso8601_timestamp(eventtime) as timestamp(6) with time zone) AS eventtime, page, referrer FROM source ) SELECT * FROM renamed {% if is_incremental() %} -- this filter is only applied on an incremental run WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }}) {% endif %} Now, create a customer_sessions table, which is used to create the next table. It calculates when a particular session has started and ended. SELECT cookie_id, last_value(customer_id) IGNORE NULLS OVER ( PARTITION BY cookie_id ORDER BY session_started ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS customer_id, session_started, lead(session_started, 1, current_timestamp(6)) OVER (PARTITION BY cookie_id ORDER BY session_started asc) AS session_ended FROM {{ ref(&quot;src_sessions&quot;) }} Since the sessionization (the calculating and connecting clicks with sessions) can affect older sessions, you should use the MERGE incremental strategy to update existing records and insert only new records into the sessionized_clicks table based on the clickid column. {{ config( materialized=&#39;incremental&#39;, unique_key=&quot;clickid&quot;, incremental_strategy=&#39;merge&#39;, ) }} with sessions as ( SELECT date_diff(&#39;hour&#39;, lag(c.eventtime) OVER w, c.eventtime) &gt; 1 AS new_session, {{ dbt_utils.star(ref(&quot;src_clicks&quot;), &quot;c&quot;) }}, {{ dbt_utils.star(ref(&quot;customer_sessions&quot;), &quot;s&quot;, [&quot;session_started&quot;, &quot;session_ended&quot;]) }}, first_value(c.referrer) IGNORE NULLS OVER (PARTITION BY s.customer_id ORDER BY c.eventtime ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS channel, row_number() OVER w AS clickid, min(eventtime) OVER w AS session_started, max(eventtime) OVER w AS session_ended FROM {{ ref(&quot;src_clicks&quot;) }} c JOIN {{ ref(&quot;customer_sessions&quot;) }} s ON c.visitorid = s.cookie_id AND c.eventtime between s.session_started AND s.session_ended window w AS ( PARTITION BY c.visitorid ORDER BY c.eventtime ) ), sequenced_sessions as ( SELECT {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }}, sum(if(new_session, 1, 0)) OVER w AS session_sequence, clickid, customer_id, session_started, session_ended, channel FROM sessions WINDOW w AS ( PARTITION BY visitorid ORDER BY eventtime ) ) SELECT visitorid || &#39;_&#39; || cast(session_sequence as varchar) || &#39;_&#39; || cast(clickid as varchar) AS clickid, visitorid || &#39;_&#39; || cast(session_sequence as varchar) AS sessionid, customer_id, session_started, session_ended, channel, {{ dbt_utils.star(ref(&quot;src_clicks&quot;)) }} FROM sequenced_sessions Summary dbt and Trino are well maintained and trusted open source projects with thrilling communities that are always ready to learn more and expand the ecosystem. Starburst improves the landscape of broad Trino features and capabilities by offering enhanced built-in security systems, SaaS connectors, UI and much more. If you want to learn more about dbt, Trino, or Starburst and how they coexist, drop us a message on the Trino #python-client or the dbt #db-presto-trino Slack channels. Don’t hesitate to ping us directly on Slack, as well. Thanks, Przemek and Michiel","headline":"Refresh your data faster using incremental models","image":"https://docs.starburst.io/assets/img/logo/dbt.svg","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.starburst.io/blog/2022-11-30-dbt3-refresh-your-data-faster-html/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://docs.starburst.io/assets/img/logo/starburst-reverse.png"}},"url":"https://www.starburst.io/blog/2022-11-30-dbt3-refresh-your-data-faster-html/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>


<header class="main-header navbar-expand-sm">
  <div class="navbar fixed-top navbar-dark">
    <div class="navbar-left-container">
      <a class="navbar-brand" href="https://www.starburst.io/">
        <img src="/assets/img/logo/starburst_KO-T.png" height="32" alt="Starburst">
      </a>
      <span class="navbar-divider"></span>
      <a href="/" class="header-text">Documentation</a>
    </div>
    
    <div class="nav-item dropdown" id="site-search">
  <div id="dropdownSearchDisplay" aria-labelledby="dropdownSearch">
    <div id="algolia-search">
      <div id="searchbox"></div>
      <div id="refinement-list">
        <h6>Filter:</h6>
      </div>
      <div id="hits"></div>
      <div id="stats"></div>
    </div>
  </div>
</div>

    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>
    <nav class="primary-nav">
      <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-layout navbar-nav mr-auto">
          <li class="nav-item dropdown">
            <a id="get-started"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/get-started/index.html">Get started</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/get-started/concepts.html">Concepts</a>
              <a class="dropdown-item" href="/get-started/architecture.html">Architecture</a>
              <a class="dropdown-item" href="/get-started/data-sources-catalogs.html">Data sources and catalogs</a>
              <a class="dropdown-item" href="/get-started/data-lake.html">Data lake</a>
              <a class="dropdown-item" href="/get-started/security.html">Security</a>
              <a class="dropdown-item" href="/get-started/choose-your-starburst-product.html">Choose your Starburst product</a>
              <a class="dropdown-item" href="/data-consumer/index.html">Data consumer</a>
              <a class="dropdown-item" href="/data-engineer/index.html">Data engineer</a>
              <a class="dropdown-item" href="/platform-administrator/index.html">Platform administrator</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-galaxy"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Starburst Galaxy" data-is-click="false"
              href="/starburst-galaxy/index.html">Starburst Galaxy</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-galaxy/get-started/index.html">Get started</a>
              <a class="dropdown-item" href="/starburst-galaxy/global/get-support.html">Help center</a>
              <a class="dropdown-item" href="/starburst-galaxy/query/index.html">Query</a>
              <a class="dropdown-item" href="/starburst-galaxy/catalogs/index.html">Catalogs</a>
              <a class="dropdown-item" href="/starburst-galaxy/catalog-explorer/index.html">Catalog explorer</a>
              <a class="dropdown-item" href="/starburst-galaxy/clusters/index.html">Clusters</a>
              <a class="dropdown-item" href="/starburst-galaxy/data-products/index.html">Data products</a>
              <a class="dropdown-item" href="/starburst-galaxy/partner-connect.html">Partner connect</a>
              <a class="dropdown-item" href="/starburst-galaxy/admin/index.html">Admin</a>
              <a class="dropdown-item" href="/starburst-galaxy/access-control/index.html">Access control</a>
              <a class="dropdown-item" href="/starburst-galaxy/cloud-settings/index.html">Cloud settings</a>
              <a class="dropdown-item" href="/starburst-galaxy/security/index.html">Security</a>
              <a class="dropdown-item" href="/starburst-galaxy/sso/index.html">Single sign-on</a>
              <a class="dropdown-item" href="/starburst-galaxy/troubleshooting/index.html">Troubleshooting</a>
              <a class="dropdown-item" href="/starburst-galaxy/python/index.html">Python</a>
              <a class="dropdown-item" href="/starburst-galaxy/api.html">API</a>
              <a class="dropdown-item" href="/starburst-galaxy/sql/index.html">SQL</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="starburst-enterprise"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/starburst-enterprise/index.html">Starburst Enterprise</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/starburst-enterprise/try/index.html">Try Starburst Enterprise</a>
              <a class="dropdown-item" href="/starburst-enterprise/web-ui/index.html">Web UI</a>
              <a class="dropdown-item" href="/starburst-enterprise/sql.html">SQL</a>
              <a class="dropdown-item" href="/starburst-enterprise/admin-topics/index.html">Administration</a>
              <a class="dropdown-item" href="/starburst-enterprise/k8s/index.html">Kubernetes deployments</a>
              <a class="dropdown-item" href="/starburst-enterprise/starburst-admin/index.html">Starburst Admin</a>
              <a class="dropdown-item" href="/latest/index.html">Reference documentation</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="ecosystems"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="Get started" data-is-click="false"
              href="/ecosystems/index.html">Ecosystems</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/ecosystems/amazon/index.html">Amazon AWS</a>
              <a class="dropdown-item" href="/ecosystems/google/index.html">Google Cloud</a>
              <a class="dropdown-item" href="/ecosystems/microsoft/index.html">Microsoft Azure</a>
              <a class="dropdown-item" href="/ecosystems/redhat/index.html">Red Hat OpenShift</a>
            </div>
          </li>
          <li class="nav-item dropdown">
            <a id="resources"
               class="nav-link dropdown-toggle" 
              aria-haspopup="true" aria-label="resources" data-is-click="false"
              href="/resources.html">Resources</a>
            <div class="dropdown-menu dropdown-docs">
              <a class="dropdown-item" href="/support.html">Support</a>
              <a class="dropdown-item" href="/security/index.html">Security</a>
              <a class="dropdown-item" href="https://www.starburst.io/blog/technical">Technical blog</a>
              <a class="dropdown-item" href="/videos/index.html">Video library</a>
              <a class="dropdown-item" href="https://academy.starburst.io/">Starburst Academy</a>
              <a class="dropdown-item" href="/glossary.html">Glossary</a>
              <a class="dropdown-item" href="/conventions.html">Conventions</a>
              <a class="dropdown-item" href="/iconography.html">Iconography</a>
              <a class="dropdown-item" href="https://www.starburst.io/community/forum/">Starburst forum</a>
            </div>
          </li>
        </ul>
      </div>
    </nav>
</header>

    <div class="landing-page">
        <div class="sep-hero">
  <div class="container sep-parent">
    <div class="row">
      <div class="col-md-12">
        <h1><a href="/blog/">Starburst developer blog</a></h1>
        <p class="lead">The latest news from our users, engineers, writers, and
        product folks for all our peers and friends out there.</p>
        <p>Want even more updates and information? Go to the
          <a href="https://blog.starburst.io/">Starburst company blog</a>.</p>
      </div>
    </div>
  </div>
</div>

  


<div class="content container-fluid post-container clearfix spacer-30">

  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
    <div class="container">
      <div class="row">

        <div class="col-xl-3">
          <h3>Contents</h3>
          <ul class="list-group">
            
              
                <a class="list-group-item" href="/blog/2022-11-30-dbt0-introduction.html">Building lakehouse with dbt and Trino</a>
              
            
            
              
                <a class="list-group-item" href="/blog_dbt/2022-11-30-dbt1-trino-setup.html">Setting up Trino for dbt</a>
              
            
              
                <a class="list-group-item" href="/blog_dbt/2022-11-30-dbt2-first-dbt-data-pipeline.html">First dbt-trino data pipeline</a>
              
            
              
                <li class="list-group-item active">Refresh your data faster using incremental models</li>
              
            
          </ul>
        </div>

        <div class="col-xl-9">
          <header class="post-header">
            <h1 class="post-title p-name" itemprop="name headline">
              Refresh your data faster using incremental models</h1>
            <p class="post-meta">
              <time class="dt-published" abbrtime="2022-11-30T00:00:00-06:00" itemprop="datePublished">
                Nov 30, 2022
              </time> |

     Michiel De Smet
     
     
     <a href="https://github.com/mdesmet" target="_blank"><i class="fab fa-github"></i></a>
     
     ,
     


     Przemek Denkiewicz
     
     <a href="https://twitter.com/hovaesco" target="_blank"><i class="fab fa-twitter"></i></a>
     
     
     <a href="https://github.com/hovaesco" target="_blank"><i class="fab fa-github"></i></a>
     
     

</p>
          </header>

          <div class="content width clearfix" itemprop="articleBody"><img src="../assets/img/logo/dbt.svg" style="float: right;"><p><em>This is part three of the lakehouse ETL with dbt and Trino series. <a href="/blog/2022-11-30-dbt0-introduction.html">Start at
the introduction</a> if you haven’t
already.</em></p>

<h2 id="incremental-models">Incremental models</h2>

<p>To refresh data faster, you can use <a href="https://docs.getdbt.com/docs/build/incremental-models">incremental
models</a> which limit the
amount of data loaded to the target table and significantly reduces loading
time. The first time an incremental model is run, the table is created by
transforming all rows from the source. On subsequent runs, dbt transforms only
the rows in your model that you tell dbt to filter for inserting them into
target table. Incremental models vastly improve performance and reduces compute
costs.</p>

<p>To use incremental models just add <code class="language-plaintext highlighter-rouge">materialized='incremental'</code> into your model
configuration:</p>

<pre class="highlight">
<code>{{
    config(
        materialized='incremental',
        unique_key='id'
    )
}}

SELECT * FROM ...
</code>
</pre>

<p>A <code class="language-plaintext highlighter-rouge">unique_key</code> determines whether a record has new values and should be updated.
By using <code class="language-plaintext highlighter-rouge">unique_key</code>, you can ensure that each row from the source table is
represented by a single row in your incremental model, without duplicates. Not
specifying a <code class="language-plaintext highlighter-rouge">unique_key</code> results in append-only behavior, which means dbt
inserts all rows returned by the model’s SQL into the preexisting target table
without regard for whether the rows represent duplicates.</p>

<p>In cases where you need multiple columns in combination to uniquely identify
each row, you can pass these columns as a list similar to <code class="language-plaintext highlighter-rouge">unique_key = ['id',
'user_id']</code>.</p>

<h2 id="reduce-data-for-processing">Reduce data for processing</h2>

<p>To tell dbt which rows it should transform on an incremental run, wrap valid SQL
that filters for these rows in the <code class="language-plaintext highlighter-rouge">is_incremental()</code> macro.</p>

<p>This filter is only applied on subsequent incremental runs.</p>

<p>Include this macro in the model configuration:</p>

<pre class="highlight">
<code>SELECT * FROM ...

{% if is_incremental() %}
  WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }})
{% endif %}
</code>
</pre>

<h2 id="incremental-strategies">Incremental strategies</h2>

<p>The dbt-trino adapter supports multiple incremental strategies which instruct
how the data is loaded into the target table. Different approaches may vary
by effectiveness depending on the volume of data, the reliability of your
<code class="language-plaintext highlighter-rouge">unique_key</code>, or the availability of certain features.</p>

<p>dbt-trino supports the following incremental strategies:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">append</code> (default)</li>
  <li><code class="language-plaintext highlighter-rouge">delete+insert</code></li>
  <li><code class="language-plaintext highlighter-rouge">merge</code></li>
</ul>

<h3 id="append"><code class="language-plaintext highlighter-rouge">append</code></h3>

<p>The default incremental strategy is <code class="language-plaintext highlighter-rouge">append</code>, which only adds the new records
based on the condition specified in the <code class="language-plaintext highlighter-rouge">is_incremental()</code> conditional block. It
can be configured without a <code class="language-plaintext highlighter-rouge">unique_key</code>, since it only inserts the data into
the target table.</p>

<pre class="highlight">
<code>{{
    config(
      materialized = 'incremental'
  )
}}
SELECT * FROM ...
</code>
</pre>

<h3 id="deleteinsert"><code class="language-plaintext highlighter-rouge">delete+insert</code></h3>

<p>Through the <code class="language-plaintext highlighter-rouge">delete+insert</code> incremental strategy, you can instruct dbt to use a
two-step incremental approach. It deletes the records detected through the
configured <code class="language-plaintext highlighter-rouge">is_incremental()</code> block before re-inserting them.</p>

<pre class="highlight">
<code>{{
    config(
      materialized = 'incremental',
      unique_key='user_id',
      incremental_strategy='delete+insert',
      )
}}
SELECT * FROM ...
</code>
</pre>

<h3 id="merge"><code class="language-plaintext highlighter-rouge">merge</code></h3>

<p>Through the <code class="language-plaintext highlighter-rouge">merge</code> incremental strategy, dbt-trino constructs a <code class="language-plaintext highlighter-rouge">MERGE</code>
statement which inserts new and updates existing records based on the unique
key.</p>

<p>Note that some connectors in Trino have limited or no support for <code class="language-plaintext highlighter-rouge">MERGE</code>.</p>

<pre class="highlight">
<code>{{
    config(
      materialized = 'incremental',
      unique_key='user_id',
      incremental_strategy='merge',
      )
}}
SELECT * FROM ...
</code>
</pre>

<h2 id="refresh-data-faster-on-your-lakehouse">Refresh data faster on your lakehouse</h2>

<p>Refresh your data faster using the incremental models described.</p>

<p>Since you only need to insert new records that appeared from the day before,
based on the <code class="language-plaintext highlighter-rouge">event_time</code> column, loading the clicks data into the src_clicks
view in the data lake could be an append incremental strategy.</p>

<pre class="highlight">
<code>{{
    config(
        materialized='incremental'
    )
}}

with source as (

    SELECT * FROM {{ source('website', 'clicks') }}

),

renamed as (

    SELECT
        visitorid,
        useragent,
        language,
        event,
        cast(from_iso8601_timestamp(eventtime) as timestamp(6) with time zone) AS eventtime,
        page,
        referrer

    FROM source

)

SELECT * FROM renamed

{% if is_incremental() %}

    -- this filter is only applied on an incremental run
    WHERE eventtime &gt; (SELECT max(eventtime) FROM {{ this }})

{% endif %}
</code>
</pre>

<p>Now, create a <code class="language-plaintext highlighter-rouge">customer_sessions</code> table, which is used to create the next table.
It calculates when a particular session has started and ended.</p>

<pre class="highlight">
<code>SELECT

    cookie_id,
    last_value(customer_id) IGNORE NULLS OVER (
        PARTITION BY cookie_id ORDER BY session_started ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS customer_id,
    session_started,
    lead(session_started, 1, current_timestamp(6)) OVER (PARTITION BY cookie_id ORDER BY session_started asc) AS session_ended

FROM {{ ref("src_sessions") }}
</code>
</pre>

<p>Since the sessionization (the calculating and connecting clicks with sessions)
can affect older sessions, you should use the <code class="language-plaintext highlighter-rouge">MERGE</code> incremental strategy to
update existing records and insert only new records into the
<code class="language-plaintext highlighter-rouge">sessionized_clicks</code> table based on the <code class="language-plaintext highlighter-rouge">clickid</code> column.</p>

<pre class="highlight">
<code>{{
    config(
        materialized='incremental',
        unique_key="clickid",
        incremental_strategy='merge',
    )
}}

with sessions as (

    SELECT

        date_diff('hour', lag(c.eventtime) OVER w, c.eventtime) &gt; 1 AS new_session,
        {{ dbt_utils.star(ref("src_clicks"), "c") }},
        {{ dbt_utils.star(ref("customer_sessions"), "s", ["session_started", "session_ended"]) }},
        first_value(c.referrer) IGNORE NULLS OVER (PARTITION BY s.customer_id ORDER BY c.eventtime ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS channel,
        row_number() OVER w AS clickid,
        min(eventtime) OVER w AS session_started,
        max(eventtime) OVER w AS session_ended

    FROM {{ ref("src_clicks") }} c
    JOIN {{ ref("customer_sessions") }} s ON c.visitorid = s.cookie_id
    AND c.eventtime between s.session_started
    AND s.session_ended
    window w AS (
        PARTITION BY c.visitorid ORDER BY c.eventtime
    )

),

sequenced_sessions as (

    SELECT
        {{ dbt_utils.star(ref("src_clicks")) }},
        sum(if(new_session, 1, 0)) OVER w AS session_sequence,
        clickid,
        customer_id,
        session_started,
        session_ended,
        channel
    FROM sessions
    WINDOW w AS (
        PARTITION BY visitorid
        ORDER BY eventtime
    )
)

SELECT
    visitorid || '_' || cast(session_sequence as varchar) || '_' || cast(clickid as varchar) AS clickid,
    visitorid || '_' || cast(session_sequence as varchar) AS sessionid,
    customer_id,
    session_started,
    session_ended,
    channel,
    {{ dbt_utils.star(ref("src_clicks")) }}
FROM sequenced_sessions
</code>
</pre>

<h2 id="summary">Summary</h2>

<p>dbt and Trino are well maintained and trusted open source projects with
thrilling communities that are always ready to learn more and expand the
ecosystem. Starburst improves the landscape of broad Trino features and
capabilities by offering enhanced built-in security systems, SaaS connectors, UI
and much more.</p>

<p><img src="../assets/img/blog/dbt-starburst2.png" alt="How dbt works with Starburst" class="img-fluid img-screenshot" description="" width="px" style="" /></p>

<p>If you want to learn more about dbt, Trino, or Starburst and how they coexist,
drop us a message on the <a href="https://trinodb.slack.com/archives/CFPVDCDHV">Trino
#python-client</a> or the dbt
#db-presto-trino Slack channels. Don’t hesitate to ping us directly on Slack, as
well.</p>

<p>Thanks,
Przemek and Michiel</p>

          </div>
        </div>
      </div>
    </div>

    <a class="u-url" href="/blog_dbt/2022-11-30-dbt3-refresh-your-data-faster.html" hidden></a>
  </article>

</div>



    </div>


<div style="margin-bottom: 50px"></div><footer class="page-footer">
  <div class="container">
    <div class="row">
      <div class="col-md-6">
        <p style="font-weight:900">Resources</b></p>
        <ul>
          <li class="footer-item"><a href="/videos/index.html">Video library</a></li>
          <li class="footer-item"><a href="/glossary.html">Glossary</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/info/oreilly-trino-guide/" target="_blank">Free O'Reilly book - Trino: The Definitive Guide</a></li>
          <li class="footer-item"><a href="https://trino.io/broadcast/" target="_blank">Trino Community Broadcast</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/community/forum/" target="_blank">Starburst forum</a></li>
          <li class="footer-item"><a href="https://blog.starburstdata.com/" target="_blank">Starburst blog</a></li>
        </ul>
      </div>
      <div class="col-md-3">
        <p style="font-weight:900">Contact and more</p>
        <ul>
          <li class="footer-item"><a href="https://www.starburst.io" target="_blank">Starburst</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/#download" target="_blank">Start a trial</a></li>
          <li class="footer-item"><a href="/support.html" target="_blank">Get support</a></li>
          <li class="footer-item"><a href="https://www.starburst.io/contact/" target="_blank">Contact us</a></li>
        </ul>
      </div>
      <div class="col-md-3" style="text-align:right;">
        <a href="https://www.starburst.io/" target="_blank"><img src="/assets/img/logo/starburst-reverse.png" height="60" alt=" Starburst" style="margin-bottom:20px;"></a>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#copyright">Copyright © 2017-2023<br> Starburst Data</a>
        </li>
        <li class="footer-item" style="padding-right:10px;">
          <a href="/disclaimers.html#trademarks">Trademark information</a>
        </li>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 center spacer-30">
          <a href="https://twitter.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-twitter"></i></a>
          <a href="https://linkedin.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-linkedin"></i></a>
          <a href="https://www.youtube.com/channel/UCXjkuWSO9CV_cSI3Mvo4a4w" target="_blank" class="footer-icon"><i class="fab fa-youtube"></i></a>
          <a href="https://github.com/starburstdata" target="_blank" class="footer-icon"><i class="fab fa-github"></i></a>
      </div>
    </div>
  </div>
</footer>
  <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
  <script type="text/javascript" src="/assets/js/popper.min.js"></script>
  <script type="text/javascript" src="/assets/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="/assets/js/mdb.min.js"></script>
  <script type="text/javascript" src="/assets/js/custom.js"></script>
  <script type="text/javascript" src="/assets/js/algolia.js"></script>
  <script type="text/javascript" src="/assets/js/search-box.js"></script>
  <script type="text/javascript" src="/assets/js/search-results.js"></script>
</body>
</html>
